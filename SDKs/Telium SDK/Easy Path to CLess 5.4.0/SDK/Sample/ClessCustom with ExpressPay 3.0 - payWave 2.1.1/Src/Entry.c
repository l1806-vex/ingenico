/** \file Entry.c
 *
 * Application entry point.
 * This file was automatically generated by IngeDev and must be filled out
 * by the developer.
 *                   
 * Purpose :
 *
 * Each time Manager calls an application, it generates only one service
 * call that reaches your application main with the corresponding service
 * number.
 *
 * List of routines in file :
 * - give_your_domain : Return application domain.
 * - after_reset : Application reset processing.
 * -  is_name : Report application name to Manager.
 * -  is_state : Return application status (initialise or not).
 * -  idle_message : Dedicated to display idle message.
 * -  more_function : Dedicated to navigation menus.
 * -  keyboard_event : Return key pressed.
 * -  state : Print terminal content.
 * -  consult : Print daily totals.
 * -  mcall : Print call schedule.
 * -  is_time_function : Need pheripherals at the next call time_function()
 * -  time_function : Allow automatic execution of periodic functions.
 * -  is_change_init : Conditions for changing manager parameters?
 * -  modif_param : Manager reports parameters changing.
 * -  is_evol_pg : Conditions for application downloading?
 * -  is_delete : Conditions for application deletion?
 * -  file_received : Manager reports parameters file received from LLT.
 * -  message_received : Inter application messaging.
 * -  is_card_specific : Card needs a specific process?
 * -  card_inside : Transaction in progress for a specific card.
 * -  is_for_you_before : Is chip card as an ISO 7816-3?
 * -  is_for_you_after : recognise mag, smc or man card in order to be a candidate.     
 * -  cless_give_info : contactless parameters for each contactless application.  
 * -  cless_debit_aid : contactless debit with AID allready selected.  
 * -  give_interface : Services registration and priority.
 * -  entry : Call by OS for recording services and opening DLL(s). 
 */


/////////////////////////////////////////////////////////////////
//// Includes ///////////////////////////////////////////////////

#include "ClessSample_Implementation.h"


/////////////////////////////////////////////////////////////////
//// Macros & preprocessor definitions //////////////////////////

#define SERVICES_LOW_PRIORITY			30
#define SERVICES_HIGH_PRIORITY			10
#define SERVICES_DEFAULT_PRIORITY		20


/////////////////////////////////////////////////////////////////
//// Static functions definition ////////////////////////////////

void entry(void);
static int select_function_emv_ (NO_SEGMENT no, S_TRANSIN *param_in, S_TRANSOUT *param_out);
static int give_your_specific_context_(NO_SEGMENT No, S_SPECIFIC_CONTEXT *param_out);
static int Main_(unsigned int nSize, StructPt* pData);
static int give_your_domain_ (NO_SEGMENT no, S_INITPARAMOUT *param_out);
static int give_money_extended_ (NO_SEGMENT no , void * p1, S_MONEYOUT_EXTENDED * moneyout);
static int after_reset_ (NO_SEGMENT no, S_TRANSOUT *param_out);
static int is_name_(NO_SEGMENT no, S_ETATOUT *param_out);
static int is_state_(NO_SEGMENT no, S_ETATOUT *param_out);
static int idle_message_ (NO_SEGMENT no);
static int more_function_ (NO_SEGMENT no);
//static int keyboard_event_ (NO_SEGMENT noappli,S_KEY *key_in,S_KEY *key_out);
static int state_ (NO_SEGMENT no);
//static int consult_ (NO_SEGMENT no);
//static int mcall_ (NO_SEGMENT no);
static int is_time_function_ (NO_SEGMENT no, S_ETATOUT *param_out);
//static int time_function_ (NO_SEGMENT no);
static int is_change_init_(NO_SEGMENT no, S_ETATOUT *param_out);
//static int modif_param_(NO_SEGMENT noappli, S_MODIF_P *param_in);
static int is_evol_pg_ (NO_SEGMENT no, S_ETATOUT *param_out);
static int is_delete_ (NO_SEGMENT no, S_DELETE *param_out);
static int file_received_ (NO_SEGMENT no, S_FILE *param_in);
//static int message_received_ (NO_SEGMENT no, S_MESSAGE_IAM *param_in);
static int is_card_specific_ (NO_SEGMENT no, S_TRANSIN *param_in, S_ETATOUT *param_out);
//static int card_inside_ (NO_SEGMENT no, S_TRANSIN *param_in, S_TRANSOUT *param_out);
//static int is_for_you_after_ (NO_SEGMENT no, S_TRANSIN *param_in, S_CARDOUT *param_out);
//static int debit_non_emv_ (NO_SEGMENT no, S_TRANSIN * param_in, S_TRANSOUT * param_out);
static int cless_give_info_ (NO_SEGMENT no, S_TRANSIN * param_in, S_CLESS_GIVEINFO * param_out);
static int cless_debit_aid_ (NO_SEGMENT no, unsigned int nSize, void * pData);
static int cless_end_ (NO_SEGMENT nAppliNum);
static int give_interface_ (unsigned short AppliNum, void* pParamIn, void* pParamOut);
static int custom_kernel_ (unsigned int nSize, void * pData);
static int custom_appli_selection_proc (unsigned int nSize, void * pData);
static int custom_selection_gui (unsigned int nSize, void * pData);
static void	Test_DLL_Security_Presence(void);
static int give_info_cx_ (NO_SEGMENT no, void *p1, S_INFOS_CXOUT *param_out);


/////////////////////////////////////////////////////////////////

static service_desc_t Services[] = {
	{ 0, AFTER_RESET, (SAP)Main_, SERVICES_DEFAULT_PRIORITY },
	{ 0, IDLE_MESSAGE, (SAP)Main_, 249}, // Lower priority than Image Loader (250)
	//{ 0, IS_CARD_EMV_FOR_YOU, (SAP)Main_, SERVICES_DEFAULT_PRIORITY },
	{ 0, IS_CARD_SPECIFIC, (SAP)Main_, SERVICES_DEFAULT_PRIORITY },
	{ 0, IS_CHANGE_INIT, (SAP)Main_, SERVICES_DEFAULT_PRIORITY },
	{ 0, IS_DELETE, (SAP)Main_, SERVICES_DEFAULT_PRIORITY },
	//{ 0, IS_EVOL_PG, (SAP)Main_, SERVICES_DEFAULT_PRIORITY },
	//{ 0, IS_FOR_YOU_AFTER, (SAP)Main_, SERVICES_DEFAULT_PRIORITY },
	//{ 0, IS_FOR_YOU_BEFORE, (SAP)Main_, SERVICES_DEFAULT_PRIORITY },
	//{ 0, IS_LICENCED, (SAP)Main_, SERVICES_DEFAULT_PRIORITY },
	{ 0, IS_NAME, (SAP)Main_, SERVICES_DEFAULT_PRIORITY },
	{ 0, IS_STATE, (SAP)Main_, SERVICES_DEFAULT_PRIORITY },
	//{ 0, IS_TIME_FUNCTION, (SAP)Main_, SERVICES_DEFAULT_PRIORITY },
	{ 0, GIVE_YOUR_DOMAIN, (SAP)Main_, SERVICES_DEFAULT_PRIORITY },
	{ 0, GIVE_MONEY_EXTENDED, (SAP)Main_, SERVICES_DEFAULT_PRIORITY },
	{ 0, MORE_FUNCTION, (SAP)Main_, SERVICES_DEFAULT_PRIORITY },
	{ 0, STATE, (SAP)Main_, SERVICES_DEFAULT_PRIORITY },
	{ 0, CLESS_GIVE_INFO, (SAP)Main_, SERVICES_DEFAULT_PRIORITY },
	{ 0, CLESS_DEBIT_AID, (SAP)Main_, SERVICES_DEFAULT_PRIORITY },
	{ 0, CLESS_END, (SAP)Main_, SERVICES_DEFAULT_PRIORITY },
	{ 0, FILE_RECEIVED, (SAP)Main_, SERVICES_DEFAULT_PRIORITY },
	{ 0, SERVICE_CUSTOM_KERNEL, (SAP)custom_kernel_, SERVICES_DEFAULT_PRIORITY },
	{ 0, CLESS_SERVICE_CUST_IMPSEL_AS_PROC, (SAP)custom_appli_selection_proc, SERVICES_DEFAULT_PRIORITY },
	{ 0, CLESS_SERVICE_CUST_IMPSEL_GUI, (SAP)custom_selection_gui, SERVICES_DEFAULT_PRIORITY },
	{ 0, SELECT_FUNCTION_EMV, (SAP)Main_, SERVICES_DEFAULT_PRIORITY },
	{ 0, GIVE_YOUR_SPECIFIC_CONTEXT, (SAP)Main_, SERVICES_DEFAULT_PRIORITY },
	{ 0, GIVE_INFOS_CX, (SAP)Main_, SERVICES_DEFAULT_PRIORITY }
};

static const char appName[] = "CLess";
static const char coldReset[] = "Cold Reset\nFrom ";
static const char warmReset[] = "Warm Reset\nFrom ";
static const char timeToCall[] = "Time to call\nFrom ";
static const char idleMsgPart1[] = "Sample Application";
static const char idleMsgPart2[] = "Welcome !";
static const char szDate[] = "Date:%.2s/%.2s/%.2s  %.2s:%.2s\n";

static int gs_bCaKeyCheckingDone = FALSE;
static int gs_nHeaderEventMask;
static unsigned long gs_ulNoCardTimeOut = 0; // No Card timeout (in milliseconds)

static int g_bDllTpassLoaded = FALSE;

/////////////////////////////////////////////////////////////////
//// Functions //////////////////////////////////////////////////

static int give_info_cx_ (NO_SEGMENT no, void *p1, S_INFOS_CXOUT *param_out)
{
	const char MY_ZONE_REP[]  = "55 BYTES FOR INFOS"; /* 55 bytes */
	const char MY_ZONE_PRIV[] = "1234567890";         /* 10 bytes */
	S_INFOS_CXOUT        etatout;

	(void)no;
	(void)p1;

	memcpy ((char *)&etatout, (char *)param_out, sizeof(etatout));

	etatout.presence_REP  = TRUE;
	etatout.presence_PRIV = TRUE;
	memcpy(etatout.zone_REP  , MY_ZONE_REP ,  strlen(MY_ZONE_REP) );
	memcpy(etatout.zone_PRIV , MY_ZONE_PRIV , strlen(MY_ZONE_PRIV) );

	memcpy (param_out, &etatout, sizeof(etatout));
	return(FCT_OK);
}


static int give_money_extended_ (NO_SEGMENT no , void * p1, S_MONEYOUT_EXTENDED * moneyout)
{
  S_MONEYOUT_EXTENDED money_out;
 
  // Unused parameters
  (void)no;
  (void)p1;
  
  int n_NbMoney;
  S_MONEY_EXTENDED * ps_x_Money;

  memcpy (&money_out, moneyout, sizeof(S_MONEYOUT_EXTENDED));
  strcpy (money_out.etat_retour[money_out.nb_reponse].libelle , (char*)appName ) ;
  
  ClessSample_Parameters_GetMoneyExtended(&n_NbMoney, &ps_x_Money);
  memcpy(&money_out.etat_retour[money_out.nb_reponse].money[0], ps_x_Money, n_NbMoney * sizeof(S_MONEY_EXTENDED));

  money_out.etat_retour[money_out.nb_reponse].nb_money = n_NbMoney;
  money_out.nb_reponse++;
  memcpy ( moneyout , &money_out , sizeof(S_MONEYOUT_EXTENDED));
  return (FCT_OK) ;
}

/** Enable the refund in the Manager menu.
 * \param    param_out (-O) Eventually ends interrupted transaction
 * \return                                           
 *  STOP
 * \header sdk30.h
 * \source entry.c 
*/
static int select_function_emv_ (NO_SEGMENT no, S_TRANSIN *param_in, S_TRANSOUT *param_out)
{
	(void)param_in;
	param_out->noappli     = no;
	param_out->rc_payment  = 0x01; //PAIEM_KO;

	return (STOP);
}

/** Enable CGUI mode of the manager for this application.
 * \param    param_out (-O) Set the CGUI flag.
 * \return                                           
 *  FCT_OK
 * \header sdk30.h
 * \source entry.c 
*/
static int give_your_specific_context_(NO_SEGMENT No, S_SPECIFIC_CONTEXT *param_out)
{
	// Initialise the output parameter
	memset(&param_out->returned_state[param_out->response_number], 0,
		sizeof(param_out->returned_state[param_out->response_number]));

	// The name of the resource file
	strcpy(param_out->returned_state[param_out->response_number].appname, "844084----");
	param_out->returned_state[param_out->response_number].no_appli = No;
	param_out->returned_state[param_out->response_number].mask = 0;
	param_out->returned_state[param_out->response_number].type = 0;
	param_out->returned_state[param_out->response_number].support = 0;
	param_out->returned_state[param_out->response_number].cam = 0;

	// The application is CGUI compliant
	param_out->returned_state[param_out->response_number].cgui = CGUI_MASK;
	param_out->response_number++;

	return FCT_OK;
}

/** Ask application to define its working environment, Manager will select 
 *  common parameters set and adapt its internal processing.
 * \param    param_out (-O) 
 *    - application_type :   
 *      TYP_CARTE (French Bank), TYP_HEALTH(French Health), TYP_EXPORT (Export)
 *    - mask : Key "F" 031 -> Parameters initialisation (0:absent, 1:present)
 *    - response_number : should be incremented
 * \return                                           
 *  FCT_OK
 * \header sdk30.h
 * \source entry.c 
*/
static int give_your_domain_ (NO_SEGMENT no, S_INITPARAMOUT *param_out)
{
	(void) no;

	/// Return application domain to Manager
	/// Setting parameters initialisation
	param_out->returned_state[param_out->response_number].mask = MSK_ALL;
	/// International domain
	param_out->returned_state[param_out->response_number].application_type = TYP_EXPORT;
	param_out->response_number++;

	return (FCT_OK);
}


//===========================================================================
//! \brief This function tests the presence of security DLL. And if it has
//! at least a release 0204.
//===========================================================================
static void	Test_DLL_Security_Presence(void)
{
	int sec_ver;
	int ret; 
	FILE * printer;

#ifndef _SIMULPC_
	ret = ObjectLoad (OBJECT_TYPE_DLL, "SECURITY");  
#else
	ret =0;
#endif 

	if ((ret != 0) && (ret != OL_ALREADY_LOADED))
	{
		printer=fopen("PRINTER","w-");
		if (printer!=NULL)
		{
			pprintf ("\n""Custom \n");
			pprintf ("Please LOAD DLL SECURITY\n");

			pprintf ("\n\n\n\n\n");
			ttestall(PRINTER,0);
			fclose(printer);
		}
	}
	else
	{ 		
#ifndef _SIMULPC_
		sec_ver = SEC_Version();
#else
		sec_ver =0x020400;
#endif 

		if (sec_ver<0x020400)
		{
			printer=fopen("PRINTER","w-");
			if (printer!= NULL)
			{
				pprintf ("\n""Custom \n");
				pprintf ("\n""Please LOAD DLL SECURITY\nWith VERSION >= 0204");

				pprintf ("\n\n\n\n\n");
				ttestall(PRINTER,0);
				fclose(printer);
			}
		}
	}
}


/** Display a message "TPASS DLL NOT LOADED"
 * \header sdk30.h
 * \source entry.c 
*/

static void Display_No_Dll_Msg (void)
{
	MSGinfos tMsg;
	int lg_code;

	// Get the manager language (merchant language)
	lg_code = PSQ_Give_Language();

	ClessSample_Term_Read_Message(STD_MESS_DLL_TPASS, lg_code, &tMsg);
	Helper_DisplayTextMerchant(ERASE, HELPERS_MERCHANT_LINE_2, &tMsg, NOLEDSOFF);
	ClessSample_Term_Read_Message(STD_MESS_NOT_LOADED, lg_code, &tMsg);
	Helper_DisplayTextMerchant(NO_ERASE, HELPERS_MERCHANT_LINE_3, &tMsg, NOLEDSOFF);

	Helper_RefreshScreen(WAIT, HELPERS_MERCHANT_SCREEN);
}

/** Initialise data and create disks, eventually ends interrupted transaction
 *  by returning S_TRANS_OUT.
 * \param    param_out (-O) Eventually ends interrupted transaction
 * \return                                           
 *  FCT_OK
 * \header sdk30.h
 * \source entry.c 
*/

static int after_reset_ (NO_SEGMENT no, S_TRANSOUT *param_out)
{
	unsigned char chgt;
	TYPE_CHGT  type;

	(void)param_out;

	g_bDllTpassLoaded = (TPasslib_open() == 0);	///< TPass DLL Library
	
	/// Reset management
	first_init(no, &chgt, (unsigned char *)&type);	///< New software loaded ?
	if (chgt==0xFF)									///< Yes, just loaded with first execution
	{ 
		raz_init(no);								///< Reset indicator downloading
	}
	
	// Try to restore parameters from sav file
	if (ClessSample_Parameters_RestoreParam (&pTreeCurrentParam) != 0)
	{
		GTL_Traces_TraceDebug("after_reset_ : ClessSample_Parameters_RestoreParam ko");
		
		// Read default parameters
		ClessSample_Parameters_ReadDefaultParameters(&pTreeDefaultParam);
		
		if (ClessSample_Parameters_SaveParam (pTreeDefaultParam) != 0)
		{
			GTL_Traces_TraceDebug("after_reset_ : ClessSample_Parameters_SaveParam ko");
		}
		else // Parameter has been correctly loaded/saved
		{
			ClessSample_Parameters_InitParameters(&pTreeCurrentParam);
			pTreeCurrentParam = pTreeDefaultParam; // Update pTreeCurrentParam for later use...
			pTreeDefaultParam = NULL;
		}
	}
	
	// Create or restore the batch
	ClessSample_Batch_Restore ();

	ClessSample_Disk_Open_MyDisk();

	// Try to load black list parameters if existing
	ClessSample_BlackListLoad();

	// Indicate CA checking has to be done
	gs_bCaKeyCheckingDone = FALSE;

	// Init the transaction sequence counter
	ClessSample_Batch_InitTransactionSeqCounter(FALSE);

	Test_DLL_Security_Presence();

	ClessSample_Term_Initialise();

	ClessSample_DumpData_InitOutput();

	if (g_bDllTpassLoaded)
	{
		// Set the LEDs into the idle state
		HelperLedsIdleState();
	}
	else
	{
		Display_No_Dll_Msg();
	}

	return FCT_OK;
}



/** Report application name to Manager.
 * \param    param_out (-O)
 *    - appname : Application name 
 *    - no : Application number
 *    - response_number : should be incremented
 * \return                                           
 *  FCT_OK
 * \header sdk30.h
 * \source entry.c 
*/

static int is_name_(NO_SEGMENT no, S_ETATOUT *param_out)
{
	strcpy(param_out->returned_state[param_out->response_number].appname, appName);
	param_out->returned_state[param_out->response_number].no_appli = no;
	param_out->response_number++;

	return (FCT_OK);
}



/** Report application state initialise or not to Manager.
 * \param    param_out (-O)
 *    - response : 
 *      REP_OK (Initialised), REP_KO (Not initialised)  
 * \return                                           
 *  FCT_OK
 * \header sdk30.h
 * \source entry.c 
*/

static int is_state_(NO_SEGMENT no, S_ETATOUT *param_out)
{
	int retour; 
	S_STATE_PARAM state_param;

	/// Return application state
	if (g_bDllTpassLoaded)
	{
		param_out->returned_state[param_out->response_number].state.response = REP_OK;
		retour = is_name_ (no, param_out);
		
		// Parameters control checking
		if (!gs_bCaKeyCheckingDone)
		{
			ClessSample_Parameters_CheckCaKeysCrc(pTreeCurrentParam);
			ClessSample_Parameters_CreateSupportedCertificateListForKernel (pTreeCurrentParam, DEFAULT_EP_KERNEL_PAYPASS);
			ClessSample_Parameters_CreateSupportedCertificateListForKernel (pTreeCurrentParam, DEFAULT_EP_KERNEL_AMEX);
			ClessSample_Parameters_CreateSupportedCertificateListForKernel (pTreeCurrentParam, DEFAULT_EP_KERNEL_INTERAC);
			ClessSample_Parameters_BuildAIDNodes(pTreeCurrentParam);
			gs_bCaKeyCheckingDone = TRUE;

			// Here to be done just one time
			// Test if the VisaWave kernel is present
			if(VisaWave_Clear() != KERNEL_STATUS_SERVICE_NOT_AVAILABLE)
				VisaWave_SetVisaWaveKernelPresence();

			ClessSample_VisaWave_SetVisaAsiaGuiMode();
			
			if(ClessSample_VisaWave_IsVisaAsiaGuiMode())
			{
				if(ClessSample_VisaWave_GetNoCardTimeOut(&gs_ulNoCardTimeOut))
				{
					// Set the timeout for the card detection process
					PSQ_read_state_param(&state_param);
					state_param.TimeOutWaitingCardAfterAmount = gs_ulNoCardTimeOut/10;
					PSQ_write_state_param(&state_param);
				}
			}

			ClessSample_Interac_SetInteracGuiMode();

			if(ClessSample_Interac_IsInteracGuiMode())
			{
				if(ClessSample_Interac_GetNoCardTimeOut(&gs_ulNoCardTimeOut))
				{
					// Set the timeout for the card detection process
					PSQ_read_state_param(&state_param);
					state_param.TimeOutWaitingCardAfterAmount = gs_ulNoCardTimeOut/10;
					PSQ_write_state_param(&state_param);
				}
			}
		}

		// Remove Application name on the header
		EventHeader (gs_nHeaderEventMask ^ _APPLI_STATE_);
	}
	else
	{
		param_out->returned_state[param_out->response_number].state.response = REP_KO;
		retour = is_name_ (no, param_out);
	}

	return (retour);
}



/** Allows the application to display its idle message when Manager goes back 
 *  to idle (the application should have the higher priority).
 * \return                                           
 *  FCT_OK
 * \header sdk30.h
 * \source entry.c 
*/

static int idle_message_ (NO_SEGMENT no)
{
	if (g_bDllTpassLoaded)
	{
		FILE *hDisplay;
		int nFont;
		char idleMessage[256];

		(void) no;

		/// Idle message management
		hDisplay = fopen("DISPLAY","w");        	///< Open display driver.
		if (hDisplay != NULL)
		{
			nFont = GetDefaultFont();               ///< Retrieve default font
		
			CreateGraphics(_LARGE_);                ///< Create graphic font
			strcpy(idleMessage,appName);
			strcat(idleMessage, "\n");
			strcat(idleMessage,idleMsgPart1);
			strcat(idleMessage, "\n");
			strcat(idleMessage,idleMsgPart2);
			strcat(idleMessage, "\n");
			_DrawString((char*) idleMessage,  0, 20, _OFF_);
			PaintGraphics();                        ///< Display idle message

			SetDefaultFont(nFont);                  ///< Restore default font
			fclose(hDisplay);	                    ///< Close display driver
		}

		// Set the LEDs into the idle state
		HelperLedsIdleState();
	}

	return FCT_OK;
}


/** It's activated when pressing on "F" key to select the right application 
 *  to go on menu.
 * \return                                           
 *  FCT_OK
 * \header sdk30.h
 * \source entry.c 
*/

static int more_function_ (NO_SEGMENT nAppliNum)
{
	(void) nAppliNum;

	if (g_bDllTpassLoaded)
		ClessSample_Menu_MainMenuDisplay();
	else Display_No_Dll_Msg();

	return (FCT_OK);
}



/** It's activated when key is pressed and terminal is in idle mode. 
 * \param    key_in (I-)
 *    - keycode : Key pressed. 
 * \param    key_out (-O)
 *    - keycode : Key pressed, new key, 0=disable. 
 * \return                                           
 *  FCT_OK
 * \header sdk30.h
 * \source entry.c 
*/
/*static int keyboard_event_ (NO_SEGMENT noappli, S_KEY *key_in, S_KEY *key_out)
{
	/// Keyboard management
	switch (key_in->keycode)
	{
	case N0: case N1: case N2: case N3: case N4: 
	case N5: case N6: case N7: case N8: case N9: 
	case T_VAL : case T_POINT : 
		key_out->keycode = 0;               ///< Inhibit these keys to Manager for International domain
		break; 
	case F1 : case F2 : case F3 : case F4 : 
	case T_CORR : case T_ANN : case NAVI_CLEAR : case NAVI_OK : 
	case UP : case DOWN :  
	case T_F :                              ///< do not filter F key and return the same key ! 
		key_out->keycode=key_in->keycode;   ///< Return the same key value for keys above ! 
		break; 
	default :
		key_out->keycode=key_in->keycode;
		break;
	}

	return (FCT_OK);
}*/



/** It's activated on "F" key: Consultation->State. 
 *  To print terminal content.  
 * \return                                           
 *  FCT_OK
 * \header sdk30.h
 * \source entry.c 
*/
static int state_ (NO_SEGMENT no)
{
	DATE date;
	object_info_t infos;
	FILE     *hPrinter;

	/// Print application info
	ObjectGetInfo(OBJECT_TYPE_APPLI, no, &infos);       ///< Retrieve application info

	hPrinter=fopen( "PRINTER", "w-*" );                 ///< Open printer driver
	if (hPrinter!=NULL) 
	{	
		pprintf("\x1b""E%s\n""\x1b""F",appName);        ///< Print application name
		pprintf("         STATE         \n"
				"Application used as\n"
				"IngeDev Template\n\n");
		read_date(&date);                               ///< Print date and time
		pprintf(szDate, date.day, date.month, date.year, date.hour, date.minute);
		pprintf("File    : %s\n",infos.file_name);      ///< Print application file name
		pprintf("CRC     : %04x\n",infos.crc);          ///< Print application CRC
		ttestall(PRINTER, 0);

		fclose(hPrinter);                               ///< Close printer driver
	}

	return FCT_OK;
}



/** It's activated on "F" key: Consultation->Transactions. 
 *  To print transactions total receipt. 
 * \return                                           
 *  FCT_OK
 * \header sdk30.h
 * \source entry.c 
*/
/*static int consult_ (NO_SEGMENT no)
{
	DATE date;
	FILE *hPrinter;
	
	/// Print daily totals
	hPrinter=fopen("PRINTER", "w-*");                    ///< Open printer driver
	if (hPrinter!=NULL)
	{
		pprintf("\x1b""E%s\n""\x1b""F", appName);        ///< Print application name
		pprintf("        CONSULT        \n"
			    "Print daily totals here\n"
			    "Number of Debit/Credit \n"
				"Totals of Debit/Credit \n"
				"Number of Cancel\n\n");
		read_date(&date);                                ///< Print date and time
		pprintf(szDate, date.day, date.month, date.year, date.hour, date.minute);
	
		ttestall(PRINTER, 3*100);
		fclose(hPrinter);                                ///< Close printer driver
	}

	return FCT_OK;
}*/



/** It's activated on "F" key: Consultation->Call->Planning of Call. 
 *  To print call schedule receipt. 
 * \return                                           
 *  FCT_OK
 * \header sdk30.h
 * \source entry.c 
*/
/*static int mcall_ (NO_SEGMENT no)
{
	DATE date;
	FILE *hPrinter;
	
	/// Print call schedule
	hPrinter=fopen("PRINTER", "w-*");                     ///< Open printer driver
	if (hPrinter!=NULL)
	{ 
		pprintf("\x1b""E%s\n""\x1b""F", appName);         ///< Print application name
		pprintf("         MCALL         \n"
	            "Planning of call here  \n"
       			"Time release batch     \n"
				"Time loading parameters\n"
				"Time loading hotlist\n\n");
		read_date(&date);                                 ///< Print date and time
		pprintf(szDate, date.day, date.month, date.year, date.hour, date.minute);
		
		ttestall(PRINTER, 3*100);
		fclose(hPrinter);                                 ///< Close printer driver
	}

	return FCT_OK;
}*/



/** Do you need the peripherals at the next call of time_function()?.
 *  It's call every minute.
 * \param    param_out (-O)
 *    - response : 
 *      REP_OK (Manager closes all peripherals), REP_KO (Manager keeps all peripherals opened)  
 * \return                                           
 *  FCT_OK
 * \header sdk30.h
 * \source entry.c 
*/
static int is_time_function_ (NO_SEGMENT no, S_ETATOUT *param_out)
{
	int retour;

	/// Peripherals needed?
	param_out->returned_state[param_out->response_number].state.response=REP_OK;
	retour = is_name_ (no, param_out);

	return(FCT_OK);
}



/** Allow application to execute its own periodical process. 
 *  It's call every minute. 
 * \return                                           
 *  FCT_OK
 * \header sdk30.h
 * \source entry.c 
*/
/*static int time_function_ (NO_SEGMENT no)
{	
	/// Periodical function in progress 
	fopen("DISPLAY","w");                 ///< Open display driver
	printf(timeToCall);
	printf(appName);
	
	ttestall(0, 1*100);
	fclose(stdout());                     ///< Close display driver    
	
	return (FCT_OK);
}*/



/** It's activated on "F" key: Initialisation->Parameters->List.
 *  Each time Manager wants to change its own parameters.
 * \param    param_out (-O)
 *    - mask : Key "F" 031 -> Parameters modification (0:accepting, 1:refusing)
 * \return                                           
 *  FCT_OK
 * \header sdk30.h
 * \source entry.c 
*/
static int is_change_init_(NO_SEGMENT no, S_ETATOUT *param_out)
{
	S_ETATOUT etatout;
	int       retour;
	memcpy(&etatout, param_out, sizeof(etatout));

	/// accept all 
	etatout.returned_state[etatout.response_number].state.mask=0;
	memcpy(param_out,&etatout,sizeof(etatout));
	retour = is_name_ (no, param_out);
	return(FCT_OK);
}



/** It's activated on "F" key: Initialisation->Parameters->List.
 *  Each time Manager changed its own parameters.
 * \param    param_in (I-)
 *    - mask : Key "F" 031 -> Parameters modification (0:not modified, 1:modified)
 * \return                                           
 *  FCT_OK
 * \header sdk30.h
 * \source entry.c 
*/
/*static int modif_param_(NO_SEGMENT noappli, S_MODIF_P *param_in)
{
	S_MODIF_P param_changed;
	
	memcpy(&param_changed, param_in,sizeof(param_changed));
	fopen("DISPLAY","w");
	printf("MODIF_PARAM\n%04x",(int)param_changed.etatout.returned_state[0].state.mask);
	ttestall(0,200);
	fclose(stdout());
	return(FCT_OK);
}*/



/** It's activated each time Manager wants to run a downloading session (local or remote).
 *  "F" key: Evolution->Load->Local or Evolution->Remote Load
 * \param    param_out (-O)
 *    - response : 
 *      REP_OK (App authorises donwloading process), REP_KO (App refuses any downloading process)  
 * \return                                           
 *  FCT_OK
 * \header sdk30.h
 * \source entry.c 
*/
static int is_evol_pg_ (NO_SEGMENT no, S_ETATOUT *param_out)
{
	int retour;

	/// Downloading process allowed?
	param_out->returned_state[param_out->response_number].state.response=REP_OK;
	retour = is_name_ (no, param_out);

	return(FCT_OK);
}



/** It's activated each time Manager wants to delete an application.
 *  "F" key: Deletion
 * \param    param_out (-O)
 *    - response : 
 *      DEL_YES (App authorises deletion process), DEL_NO (App refuses any deletion process)  
 * \return                                           
 *  FCT_OK
 * \header sdk30.h
 * \source entry.c 
*/
static int is_delete_ (NO_SEGMENT no, S_DELETE *param_out)
{
	(void) no;

	/// Deletion process allowed?
	param_out->deleting=DEL_YES;

	return (FCT_OK);
}



/** Manager reports parameters file received from LLT.
 *  It's activated upon reception of a parameter file by the manager.
 * \param    param_in (I-)
 *    - volume_name : SYSTEM (File loaded in CFS), HOST (File loaded in DFS).
 *    - file_name : Application file name
 * \return                                           
 *  FCT_OK
 * \header sdk30.h
 * \source entry.c 
*/
static int file_received_ (NO_SEGMENT no, S_FILE *param_in)
{
	unsigned char * pSha;
	int nCRCLength;
	int nResult;
	int nIndex;
	char StrBuff[100];
	char TmpStr[10];

	(void) no;

	// Try to read parameter file and store it into an internal TLV tree structure
	nResult = ClessSample_Parameters_ReadXMLFile((char*)param_in->volume_name, (char*)param_in->file_name, &pTreeCurrentParam);
	if (nResult == STOP) // Inputed file is a parameter file 
	{
		// File has been received
		GTL_Traces_DiagnosticText ("CLESSCUST.PAR file received\n");
		
		// Prepare all the information (before the transaction) for each AID
		
		// Trace prepared data
		ClessSample_Parameters_Trace_Parameter_AID_Structure();
		
		// Compute the configuration CRC
		ClessSample_Parameters_Compute_Config_CRC(&pTreeCurrentParam, &nCRCLength, &pSha);
		{
			sprintf(StrBuff, "Parameters CRC : \n");
			
			for (nIndex=0; nIndex<nCRCLength; nIndex++)
			{
				sprintf(TmpStr, "%02x", pSha[nIndex]);
				strcat(StrBuff, TmpStr);
			}
			GTL_Traces_TraceDebug("%s", StrBuff);
		}
		return (nResult);
	}

	// Try to read black List parameter
	nResult = ClessSample_BlackListGetNewFile(param_in->volume_name, param_in->file_name);
	if (nResult == STOP) // Inputed file is a Black list parameter file 
	{
		GTL_Traces_DiagnosticText ("CLESSBLACK.PAR file received\n");
		return (nResult);
	}

	return (nResult);
}



/** Inter application messaging.
 *  It's activated each time Manager received a message in its mailbox for this application.
 * \param    param_in (I-)
 *    - sender : Sender ID.
 *    - receiver : Receiver ID.
 *    - type : IAM type.
 *    - length : Message length.
 *    - value : Message received.
 * \return                                           
 *  FCT_OK
 * \header sdk30.h
 * \source entry.c 
*/
/*static int message_received_ (NO_SEGMENT no, S_MESSAGE_IAM *param_in)
{
	FILE *prt;

	/// Print message received from application 2
	prt=fopen("PRINTER","w-");                                           ///< Open printer driver
	pprintf("\x1b""E%s\n""\x1b""F", appName);      
	pprintf ("Message IAM :\n");
	pprintf ("S:%04X R:%04X\n", param_in->sender, param_in->receiver);   ///< USER2 to TEMPLATE
	pprintf ("IAM Type : %04X \n\n", param_in->type);

	pprintf("%s\n\n\n\n\n\n", param_in->value);                          ///< Print the message received
	ttestall(PRINTER, 2*100);
	fclose(prt);                                                         ///< Close printer driver

	return (FCT_OK);
}*/



/** 
 *  It's activated when a card is inserted, swiped or manually entry.
 *  Ask the application if the card need a specific processing.
 * \param    param_out (-O)
 *    - response : 
 *      REP_OK (card processing), REP_KO (no card processing)  
 *  Only one application wants to process the card, manager calls CARD_INSIDE entry.
 *  More application wants to process the card, manager asks for card removal.
 *  If no application wants to process the card, manager goes on with selection process. 
 * \return                                           
 *  FCT_OK
 * \header sdk30.h
 * \source entry.c 
*/
static int is_card_specific_ (NO_SEGMENT no, S_TRANSIN *param_in, S_ETATOUT *param_out)
{
	int ret; 

	(void) param_in;

	/// Return application state
	param_out->returned_state[param_out->response_number].state.response = REP_KO;
	ret = is_name_ (no, param_out);
	
	return (FCT_OK);
}



/** 
 *  It's activated when an application has chosen to treat this card has specific.
 *  The transaction is done here.
 * \param    param_out (-O)
 *    - rc_payment : 
 *      PAY_OK (Transaction done), PAY_KO (Transaction rejected)  
 *  If an application retourns STOP, polling is stopped and manager asks for card removal.
 *  The application is in charge to ask for amount and currency if needed.
 * \return   
 *  STOP    Card accepted and transaction process done, polling is stop. 
 *  FCT_OK  Card refused and poll the next application.
 * \header sdk30.h
 * \source entry.c 
*/
/*static int card_inside_ (NO_SEGMENT no, S_TRANSIN *param_in, S_TRANSOUT *param_out)
{
    bool card_accepted = TRUE;

	if (card_accepted)
	{
	/// Return transaction status
	param_out->rc_payment = PAY_OK;               ///< Transaction done, polling is stop
	return (STOP);
	}
	else
	{
		return (FCT_OK);                          ///< Card refused, poll the next application
	}
}*/



/** 
 *  Ask application to recognise the mag, smart or manually card in order to be
 *  a candidate.
 * \param    param_out (-O)
 *    - cardappnumber : 1 = Card accepted, 0 = Card rejected 
 *    - cardapp : 
 *      CARD_PROCESSED (low priority) 
 *      CARD_RECOGNIZED (medium priority) 
 *      CARD_PRIORITY (high priority)
 *    - appname : Application name 
 *    - no : Application number
 *    - response_number : should be incremented
 * \return   
 *  FCT_OK
 * \header sdk30.h
 * \source entry.c 
*/
/*static int is_for_you_after_ (NO_SEGMENT no, S_TRANSIN *param_in, S_CARDOUT *param_out)
{
	
	/// case of chip card
	if (param_in->support == CHIP_SUPPORT)
	{
		if(param_in->power_on_result == 0)
		{
			/// accept this card 
			param_out->returned_state[param_out->response_number].cardappnumber = 1;
			param_out->returned_state[param_out->response_number].cardapp [0].priority = CARD_PROCESSED;
		}
		else
		{
			/// reject the card
			param_out->returned_state[param_out->response_number].cardappnumber = 0;
		}
	}

	/// case of stripe 2 card
	if (param_in->support == TRACK2_SUPPORT)
	{
		/// accept this card 
		param_out->returned_state[param_out->response_number].cardappnumber = 1;
		param_out->returned_state[param_out->response_number].cardapp [0].priority = CARD_PRIORITY;
	}
	
	/// case of Card Number Manual entry
	if (param_in->support == OPERATOR_SUPPORT)
	{
		/// accept this card 
		param_out->returned_state[param_out->response_number].cardappnumber = 1;
		param_out->returned_state[param_out->response_number].cardapp [0].priority = CARD_PRIORITY;
	}

	/// give my application name 
	strcpy (param_out->returned_state[param_out->response_number].appname, appName) ;
	/// give my application number
	param_out->returned_state[param_out->response_number].no_appli = no;
	/// give my card name
	strcpy (param_out->returned_state[param_out->response_number].cardapp [0].cardappname, "Template") ;
	/// increment the response number 
	param_out->response_number++;

	return (FCT_OK);
}*/



/** 
 * ¨Process a non EMV chip card or a magnetic card or manual entry transaction.
 * \param    param_out (-O)
 * \param    param_out (-O)
 *    - rc_payment : 
 *      PAY_OK (Transaction done), PAY_KO (Transaction rejected)  
 * \return   
 *  FCT_OK
 * \header sdk30.h
 * \source entry.c 
*/
/*static int debit_non_emv_ (NO_SEGMENT no, S_TRANSIN * param_in, S_TRANSOUT * param_out)
{
	FILE *prt;
	int i;

	prt  = fopen("PRINTER", "w-");
	
	/// case of chip card 
	if ( param_in->support == CHIP_SUPPORT )
	{
		pprintf("\x1b""E%s\n""\x1b""F", appName); 
		if (param_in->historical_bytes.length != 0)
		{
			pprintf("Atr:\n");
			for (i=0; i<param_in->historical_bytes.length; i++)
			{
				pprintf("%02X ", param_in->historical_bytes.historic[i]);
			}
		}
		else
		{
			pprintf("Synchronous card\n");
			pprintf("or Chip mute\n");
		}
		pprintf("\n\n\n\n\n\n");
	}

	/// case of stripe 2 card
	if ( param_in->support == TRACK2_SUPPORT )
	{
		pprintf("\x1b""E%s\n""\x1b""F", appName); 
		pprintf("Track2:\n%s\n\n\n\n\n\n", param_in->track2); 
	}
	
	/// case of Card Number Manual entry
	if ( param_in->support == OPERATOR_SUPPORT )
	{
		pprintf("\x1b""E%s\n""\x1b""F", appName); 
		pprintf("Manual Entry:\n%s\n\n\n\n\n\n",param_in->track2); 
	}
	
	ttestall(PRINTER,2*100);
	fclose(prt);

	param_out->noappli      = no;                 ///< Return application number
	param_out->rc_payment = PAY_OK;               ///< Transaction done
	return (FCT_OK);
}*/



/** 
 * ¨Get the contactless information for transaction.
 * \param    param_out (-O)
 * \param    param_out (-O)
 *    - rc_payment : 
 *      PAY_OK (Transaction done), PAY_KO (Transaction rejected)  
 * \return   
 *  FCT_OK
 * \header sdk30.h
 * \source entry.c 
*/
static int cless_give_info_ (NO_SEGMENT no, S_TRANSIN * param_in, S_CLESS_GIVEINFO * param_out)
{
	unsigned char ucCurrencyCode[2];
	int nTransactionType;
	unsigned long ulAmountOtherBin = 0;

	(void) no;
	nTransactionType = 0;

	ClessSample_Customisation_SetUsedPaymentScheme (CLESS_SAMPLE_CUST_UNKNOWN);
	
	// Prepare maximum transaction data for kernel purpose before card presentation
	// Input parameters
	if (!ClessSample_Fill_InitSharedBufferWithKernels (&g_pKernelSharedBuffer))
	{
		GTL_Traces_TraceDebug("cless_give_info_ : ClessSample_Fill_InitSharedBufferWithKernels failed");
		goto End;
	}

	// Add transaction data (amount, date, time, etc).
	ucCurrencyCode[0] = param_in->currency.code[0] - 0x30;
	ucCurrencyCode[1] = ((param_in->currency.code[1] - 0x30) << 4) + (param_in->currency.code[2] - 0x30);

	if (ClessSample_Menu_IsEnableInputTransactionType()) // Is transactionType must be inputed
	{
		// Input nTransactionType
		ClessSample_Menu_TransactionTypeMenuDisplay(param_in->currency.nom, &(param_in->amount), &ulAmountOtherBin, &nTransactionType);

		// Anti-bug:
		if (ulAmountOtherBin > param_in->amount)
		{
			MSGinfos tMsg;
			int nMerchLang;

			// Display : bad amount other inputed for Cless transaction
			nMerchLang = PSQ_Give_Language();

			ClessSample_Term_Read_Message(STD_MESS_ERROR, nMerchLang, &tMsg);
			Helper_DisplayTextMerchant(ERASE, HELPERS_MERCHANT_LINE_2, &tMsg, LEDSOFF);
			Helper_RefreshScreen(WAIT, HELPERS_MERCHANT_SCREEN);

			nTransactionType = -1; // Error
		}
	}
	else
	{
		// Get the transaction type
		if (param_in->transaction == CREDIT_TR)
			nTransactionType = CLESS_SAMPLE_TRANSACTION_TYPE_REFUND;
		else
			nTransactionType = CLESS_SAMPLE_TRANSACTION_TYPE_DEBIT;
	}

	// Error management
	if (nTransactionType == -1)
		goto End;

	// Save CLESS_GIVE_INFO input data for future use
	ClessSample_Fill_PrepareAndSaveClessGiveInfoTransactionData ((param_in->entry != NO_ENTRY), (unsigned char)nTransactionType, ucCurrencyCode, param_in->currency.posdec, param_in->currency.nom, param_in->amount, ulAmountOtherBin);
	
	// Fill the output structure with the data to be used for application selection
	if (!ClessSample_Fill_GiveInfo (param_out, &pTreeCurrentParam))
	{
		GTL_Traces_TraceDebug("cless_give_info_ : ClessSample_Fill_GiveInfo failed");
		goto End;
	}

	if (ClessSample_VisaWave_IsVisaAsiaGuiMode())
	{
		// Start timer
		VisaWave_StartDetectionTimer();
		ClessSample_VisaWave_GetLastTransactionData();
	}

	// ExpressPay specific (Mobile CVM has not been performed)
	ClessSample_ExpressPay_UnsetMobileCVM();

End:
	return (FCT_OK);
}


/** 
 * ¨Process a Cless debit with AID already selected.
 * \param    param_out (-O)
 * \param    param_out (-O)
 *    - rc_payment : 
 *      PAY_OK (Transaction done), PAY_KO (Transaction rejected)  
 * \return   
 *  FCT_OK
 * \header sdk30.h
 * \source entry.c 
*/
static int cless_debit_aid_ (NO_SEGMENT no, unsigned int nSize, void * pData)
{
	// Specific variables to manage share buffer
	int nResult = C_CLESS_CR_END;
	int nKernelToUse;
	T_SHARED_DATA_STRUCT * pSharedStruct;


	(void) no;
	(void) nSize;

	VisaWave_UnsetpayWaveFallBack();
	ClessSample_payWave_SetQVSDCNotAllowedForAmount(FALSE);

	// Transaction is not ok
	ClessSample_Common_SetTransactionState(FALSE);

	if(ClessSample_VisaWave_IsVisaAsiaGuiMode())
	{
		// "No Card" message will not be displayed
		VisaWave_SetDisplayNoCard(FALSE);
	}

	if(ClessSample_Interac_IsInteracGuiMode())
	{
		// "No Card" message will not be displayed
		Interac_SetDisplayNoCard(FALSE);
	}

Restart:

	// Input parameters
	pSharedStruct = ((T_SERVICE_CALL_SHARED_EXCHANGE_STRUCT *)pData)->pDataStruct;

	// Indicates the cless kernel is not yet known
	ClessSample_Customisation_SetUsedPaymentScheme (CLESS_SAMPLE_CUST_UNKNOWN);

	// Input parameters (g_pKernelSharedBuffer has been initialised in the CLESS_GIVE_INFO service, just clear it)
	GTL_SharedExchange_ClearEx (g_pKernelSharedBuffer, FALSE);

	// Fill the shared buffer with the transaction data
	if (!ClessSample_Fill_TransactionGenericData (g_pKernelSharedBuffer))
	{
		GTL_Traces_TraceDebug("cless_debit_aid_ : ClessSample_Fill_TransactionGenericData failed");
		return (nResult);
	}

	// Dump data provided on CLESS_DEBIT_AID service (content of shared buffer)
	///ClessSample_DumpData_DumpSharedBufferWithTitle(pSharedStruct, "CLESS_DEBIT_AID");

	// Fill buffer with AID related data
	if (!ClessSample_Fill_AidRelatedData (g_pKernelSharedBuffer, pSharedStruct, &nKernelToUse))
	{
		GTL_Traces_TraceDebug("cless_debit_aid_ : ClessSample_Fill_AidRelatedData failed");
		return (nResult);
	}

	if (ClessSample_payWave_IsQVSDCNotAllowedForAmount())
	{
		GTL_Traces_TraceDebug("cless_debit_aid_ : ClessSample_Fill_AidRelatedData failed Amount greater than TAG_EP_CLESS_TRANSACTION_LIMIT");
		return (CLESS_CR_MANAGER_REMOVE_AID);
	}

	// Call kernel in relationship with AID
	switch (nKernelToUse)
	{
		case DEFAULT_EP_KERNEL_PAYPASS :
			// Clear input data for next call
			GTL_SharedExchange_Clear(pSharedStruct);
			nResult = ClessSample_PayPass_PerformTransaction(g_pKernelSharedBuffer);
			break;

		case DEFAULT_EP_KERNEL_VISA :
			if(VisaWave_isVisaWaveProcessing())
			{
				nResult = ClessSample_VisaWave_PerformTransaction(g_pKernelSharedBuffer);
				if(nResult == VISAWAVE_STATUS_PAYWAVE_CARD)
				{
					VisaWave_SetpayWaveFallBack();
					goto Restart;
				}
				else
				{
					// Clear input data for next call
					GTL_SharedExchange_Clear(pSharedStruct);
				}
			}
			else
			{
				GTL_SharedExchange_Clear(pSharedStruct);
				nResult = ClessSample_payWave_PerformTransaction(g_pKernelSharedBuffer);
			}
			break;

		case DEFAULT_EP_KERNEL_AMEX :
			GTL_SharedExchange_Clear(pSharedStruct);
			nResult = ClessSample_ExpressPay_PerformTransaction(g_pKernelSharedBuffer);
			break;

		case DEFAULT_EP_KERNEL_DISCOVER :
			GTL_SharedExchange_Clear(pSharedStruct);
			nResult = ClessSample_Discover_PerformTransaction(g_pKernelSharedBuffer);
			break;

		case DEFAULT_EP_KERNEL_INTERAC :
			GTL_SharedExchange_Clear(pSharedStruct);
			nResult = ClessSample_Interac_PerformTransaction(g_pKernelSharedBuffer);
			break;

		default:
			GTL_Traces_TraceDebug("Unknown Kernel to use in cless_debit_aid() : %x", nKernelToUse);
			break;
	}

	// Manage transaction result to update pSharedStruct with data used for cashbox
	ClessSample_Common_ManageTransactionState(pSharedStruct);

	return (nResult);
}



/** 
 * \brief This entry point is called after the contact’ less transaction (or when a contact transaction is initiated).
 * It can be used to close peripheral (that had been opened in the CLESS_GIVE_INFO entry point for example) or doing 
 * any other treatments.
 * \param[in] nAppliNum Application Number.  
 * \return   
 *  	- \ref FCT_OK always.
 */
static int cless_end_ (NO_SEGMENT nAppliNum)
{
	(void) nAppliNum;
	MSGinfos tMsg;
	int nTimeout, nLang;
	
	if(ClessSample_VisaWave_IsVisaAsiaGuiMode() && VisaWave_GetDisplayNoCard())
	{
		nLang = PSQ_Give_Language();

		nTimeout = GTL_StdTimer_GetRemaining(VisaWave_GetDetectionTimer(), gs_ulNoCardTimeOut/10);
		if (nTimeout == 0)
		{
			ClessSample_Term_Read_Message(VISAWAVE_MESS_NO_CARD, nLang, &tMsg);
			Helper_DisplayTextCustomer(ERASE, HELPERS_CUSTOMER_LINE_2, &tMsg, CLESSSAMPLE_ALIGN_CENTER, LEDSOFF);
			Helper_RefreshScreen(WAIT, HELPERS_CUSTOMER_SCREEN);
		}
	}
		
	if(ClessSample_Interac_IsInteracGuiMode() && Interac_GetDisplayNoCard())
	{
		nLang = PSQ_Give_Language();

		nTimeout = GTL_StdTimer_GetRemaining(Interac_GetDetectionTimer(), gs_ulNoCardTimeOut/10);
		if (nTimeout == 0)
		{
			HelperErrorSequence (WITHBEEP);
			ClessSample_Term_Read_Message(INTERAC_MESS_NO_CARD, nLang, &tMsg);
			Helper_DisplayTextCustomer(ERASE, HELPERS_CUSTOMER_LINE_2, &tMsg, CLESSSAMPLE_ALIGN_CENTER, LEDSOFF);
			Helper_RefreshScreen(WAIT, HELPERS_CUSTOMER_SCREEN);
		}
	}

	ClessSample_Customisation_SetDoubleTapInProgress(FALSE);

	ClessSample_PayPass_DumpTransationDataLog ();

	return (FCT_OK);
}



/** 
 * \brief Services registration and priority.  
 *  For all services except idle_message, priority => 0x00 highest and 0xFF lowest
 *  For idle_message, priority => 0x00 lowest 0xFF highest
 * \header sdk30.h
 * \source entry.c 
*/
static int give_interface_ (unsigned short AppliNum, void* pParamIn, void* pParamOut)
{
	int i;

	(void)pParamIn;
	(void)pParamOut;

	for(i = 0; i < (int)(sizeof(Services) / sizeof(Services[0])); i++)
		Services[i].appli_id = AppliNum;

	ServiceRegister((sizeof(Services) / sizeof(Services[0])), Services);

	// Security DLL open 
	SEClib_Open();

	return FCT_OK;
}



/** 
 *  \brief Function called for customisation of application selection processing.
 *  \param[in] nSize Size of \a pData.
 *  \param[in] pData Data sent by the caller.
 * 	\return
 *		- CLESS_CUST_DEFAULT to use the default processing. 
 *		- CLESS_CUST_RETRY_WITH_CLESS if the transaction shall be restarted.
 *		- CLESS_CUST_RETRY_WITHOUT_CLESS if transaction shall be restarted without cless.
 *		- CLESS_CUST_STOP if the transaction shall be stopped.
 *		- CLESS_CUST_NEXT_METHOD if next application selection method shall be used (if present). 
 *		- CLESS_CUST_CONTINUE_METHOD if next application selection criteria shall be used. 
 */

static int custom_appli_selection_proc (unsigned int nSize, void * pData)
{
	T_SERVICE_CALL_SHARED_EXCHANGE_STRUCT * pSharedStruct;
	
	(void)nSize;
	pSharedStruct = (T_SERVICE_CALL_SHARED_EXCHANGE_STRUCT *)pData;

	return (ClessSample_Customisation_CustAsProc(pSharedStruct->pDataStruct));
}


//! \brief This function is called to customise the GUI during the DLL processing.
//! \param[in] pDataStruct Shared buffer containing data necessary to customise the step.
//! \return
//!	- \ref CLESS_CUST_DEFAULT if default DLL GUI shall be executed.
//!	- \ref CLESS_CUST_CONTINUE if application made customisation and default DLL GUI shall not be executed.

static int custom_selection_gui (unsigned int nSize, void * pData)
{
	T_SERVICE_CALL_SHARED_EXCHANGE_STRUCT * pSharedStruct;
	
	(void)nSize;
	pSharedStruct = (T_SERVICE_CALL_SHARED_EXCHANGE_STRUCT *)pData;

	if(ClessSample_VisaWave_IsVisaAsiaGuiMode())
		return (ClessSample_Customisation_SelectionGui(pSharedStruct->pDataStruct));
	else if(ClessSample_Interac_IsInteracGuiMode())
		return (ClessSample_Customisation_Interac_SelectionGui(pSharedStruct->pDataStruct));
	else
		return(CLESS_CUST_DEFAULT);
}


/** 
 * \brief This service is called by the contactless kernels for customisation processing.
 * This is the application that provide kernel the service and the application type to call for customisation. 
 * \param[in] nSize Size of \a pData (not used as \a pData is a shared service call struct).
 * \param[in,out] pData Data buffer to be used to get and provide data to the kernel.  
 * \return   
 *  	- \ref FCT_OK always.
 */
static int custom_kernel_ (unsigned int nSize, void * pData)
{
	int nResult;
	T_SERVICE_CALL_SHARED_EXCHANGE_STRUCT * pSharedStruct;

	(void) nSize;
	
	pSharedStruct = (T_SERVICE_CALL_SHARED_EXCHANGE_STRUCT *)pData;

	// Call the customisation depending on the kernel used
	nResult = ClessSample_Customisation_Process (pSharedStruct->pDataStruct);

	return (nResult);
}



/** 
 * \brief This service is called by the contactless kernels for customisation processing.
 * This is the application that provide kernel the service and the application type to call for customisation. 
 * \param[in] nSize Size of \a pData (not used as \a pData is a shared service call struct).
 * \param[in,out] pData Data structure containing the service data to be used.  
 * \return The service returned code.
 */
static int Main_(unsigned int nSize, StructPt* pData)
{
	NO_SEGMENT AppliNum;
	int nResult;

	(void)nSize;

	AppliNum = (NO_SEGMENT)ApplicationGetCurrent();
	switch(pData->service)
	{
	case AFTER_RESET:
		nResult = after_reset_(AppliNum, &pData->Param.AfterReset.param_out);
		break;
	case IS_DELETE:
		nResult = is_delete_(AppliNum, &pData->Param.IsDelete.param_out);
		break;
	case IS_NAME:
		nResult = is_name_(AppliNum, &pData->Param.IsName.param_out);
		break;
	case IS_STATE:
		nResult = is_state_(AppliNum, &pData->Param.IsState.param_out);
		break;
	case FILE_RECEIVED:
		nResult = file_received_(AppliNum, &pData->Param.FileReceived.param_in);
		break;
	case GIVE_YOUR_DOMAIN:
		nResult = give_your_domain_(AppliNum, &pData->Param.GiveYourType.param_out);
		break;
	case GIVE_MONEY_EXTENDED:
		nResult = give_money_extended_(AppliNum, NULL, &pData->Param.GiveMoneyExtended.param_out);
		break;
	case MORE_FUNCTION:
		nResult = more_function_(AppliNum);
		break;
	case IS_CARD_SPECIFIC:
		nResult = is_card_specific_(AppliNum, &pData->Param.ClessIsSpecific.param_in, &pData->Param.ClessIsSpecific.param_out);
		break;
	case IS_CHANGE_INIT:
		nResult = is_change_init_(AppliNum, &pData->Param.IsChangeInit.param_out);
		break;
	case IS_EVOL_PG:
		nResult = is_evol_pg_ (AppliNum, &pData->Param.IsEvolPg.param_out);
		break;
	case IS_TIME_FUNCTION:
		nResult = is_time_function_(AppliNum, &pData->Param.IsTimeFunction.param_out);
		break;
	case STATE:
		nResult = state_(AppliNum);
		break;
	case IDLE_MESSAGE:
		nResult = idle_message_(AppliNum);
		break;
	case CLESS_GIVE_INFO:
		nResult = cless_give_info_ (AppliNum, &pData->Param.ClessGiveInfo.param_in, &pData->Param.ClessGiveInfo.param_out);
		break;
	case CLESS_DEBIT_AID:
		nResult = cless_debit_aid_ (AppliNum, nSize, pData);
		break;
	case CLESS_END:
		nResult = cless_end_ (AppliNum);
		break;
	case SELECT_FUNCTION_EMV:
		nResult = select_function_emv_(AppliNum,&pData->Param.SelectFunctionEmv.param_in,&pData->Param.SelectFunctionEmv.param_out);
		break;
	case GIVE_YOUR_SPECIFIC_CONTEXT:
		nResult = give_your_specific_context_(AppliNum,&pData->Param.GiveYourSpecificContext.param_out);
		break;
	case GIVE_INFOS_CX:
		nResult = give_info_cx_ (AppliNum, NULL, &pData->Param.GiveInfosCx.param_out);
		break;
	default:
		nResult = FCT_OK;
		break;
	}

	return nResult;
}



#ifdef __cplusplus
extern "C" {
#endif

/** entry() is called by the OS for recording services and opening DLL(s).                   
 *  The RegisteryPowerFailure() can also be moved to entry().
 * \header sdk30.h
 * \source entry.c 
*/
void entry(void)
{
	object_info_t info;
	
	gs_nHeaderEventMask = EventHeader (0); // To get the initial Header Event Mask and to set the current to 0
	EventHeader (gs_nHeaderEventMask); // Restore the Header Event mask

	/// Recording services
	ObjectGetInfo(OBJECT_TYPE_APPLI, ApplicationGetCurrent(),&info);
	give_interface_(info.application_type, NULL, NULL);
	
	//memcpy(appName,info.name,OBJECT_NAME_LEN);
	//appName[OBJECT_NAME_LEN] = '\0';
}

#ifdef __cplusplus
}
#endif
