/**
 * Entry.c
 * 
 * Application entry point.
 * This file was automatically generated by IngeDev and must be filled out
 * by the developer.
 *                   
 * Purpose:
 *
 * Each time Manager calls an application, it generates only one service
 * call that reaches your application main with the corresponding service
 * number.
 *
 * List of routines in file:
 * - give_your_domain: Return application domain.
 * - after_reset: Application reset processing.
 * - is_name: Report application name to Manager.
 * - is_name_extended: Report extended application name to Manager.
 * - is_state: Return application status (initialize or not).
 * - idle_message: Dedicated to display idle message.
 * - more_function: Dedicated to navigation menus.
 * - keyboard_event: Return key pressed.
 * - state: Print terminal content.
 * - consult: Print daily totals.
 * - mcall: Print call schedule.
 * - is_time_function: Need pheripherals at the next call time_function()
 * - time_function: Allow automatic execution of periodic functions.
 * - is_change_init: Conditions for changing manager parameters?
 * - modif_param: Manager reports parameters changing.
 * - is_evol_pg: Conditions for application downloading?
 * - is_delete: Conditions for application deletion?
 * - file_received: Manager reports parameters file received from LLT.
 * - message_received: Inter application messaging.
 * - is_card_specific: Card needs a specific process?
 * - card_inside: Transaction in progress for a specific card.
 * - is_for_you_before: Is chip card as an ISO 7816-3?
 * - is_for_you_after: recognise mag, smc or man card in order to be a candidate.     
 * - give_interface: Services registration and priority.
 * - entry: Call by OS for recording services and opening DLL(s). 
 */

#include "SDK30.H"

//+++++++++++++ Macros & preprocessor definitions ++++++++++++++ 

#define __ENTER_KEY     -1
#define __BACK_KEY      -2
#define __EXIT_KEY      -3

#define NUMBER_OF_ITEMS(a) (sizeof(a)/sizeof((a)[0]))

#define SERVICES_LOW_PRIORITY           30
#define SERVICES_HIGH_PRIORITY          10
#define SERVICES_DEFAULT_PRIORITY       20

//++++++++++++++++++++++ Global variables ++++++++++++++++++++++ 

static service_desc_t Services[] = {
    { 0, GIVE_YOUR_DOMAIN, (SAP)Main, (unsigned char)SERVICES_HIGH_PRIORITY },
    { 0, AFTER_RESET, (SAP)Main, (unsigned char)SERVICES_HIGH_PRIORITY },
    { 0, GIVE_YOUR_SPECIFIC_CONTEXT, (SAP)Main, (unsigned char)SERVICES_HIGH_PRIORITY },
    { 0, IS_NAME, (SAP)Main, (unsigned char)SERVICES_HIGH_PRIORITY },
    { 0, IS_NAME_EXTENDED, (SAP)Main, (unsigned char)SERVICES_HIGH_PRIORITY },
    { 0, IS_STATE, (SAP)Main, (unsigned char)SERVICES_HIGH_PRIORITY },
    { 0, IDLE_MESSAGE, (SAP)Main, (unsigned char)SERVICES_DEFAULT_PRIORITY },
    { 0, MORE_FUNCTION, (SAP)Main, (unsigned char)SERVICES_HIGH_PRIORITY },
    { 0, KEYBOARD_EVENT, (SAP)Main, (unsigned char)SERVICES_DEFAULT_PRIORITY },
    { 0, STATE, (SAP)Main, (unsigned char)SERVICES_DEFAULT_PRIORITY },
    { 0, CONSULT, (SAP)Main, (unsigned char)SERVICES_HIGH_PRIORITY },
    { 0, MCALL, (SAP)Main, (unsigned char)SERVICES_HIGH_PRIORITY },
    { 0, IS_TIME_FUNCTION, (SAP)Main, (unsigned char)SERVICES_HIGH_PRIORITY },
    { 0, TIME_FUNCTION, (SAP)Main, (unsigned char)SERVICES_HIGH_PRIORITY },
    { 0, IS_CHANGE_INIT, (SAP)Main, (unsigned char)SERVICES_HIGH_PRIORITY },
    { 0, MODIF_PARAM, (SAP)Main, (unsigned char)SERVICES_HIGH_PRIORITY },
    { 0, IS_EVOL_PG, (SAP)Main, (unsigned char)SERVICES_HIGH_PRIORITY },
    { 0, IS_DELETE, (SAP)Main, (unsigned char)SERVICES_HIGH_PRIORITY },
    { 0, FILE_RECEIVED, (SAP)Main, (unsigned char)SERVICES_HIGH_PRIORITY },
    { 0, MESSAGE_RECEIVED, (SAP)Main, (unsigned char)SERVICES_HIGH_PRIORITY },
    { 0, IS_CARD_SPECIFIC, (SAP)Main, (unsigned char)SERVICES_HIGH_PRIORITY },
    { 0, CARD_INSIDE, (SAP)Main, (unsigned char)SERVICES_DEFAULT_PRIORITY },
    { 0, IS_FOR_YOU_AFTER, (SAP)Main, (unsigned char)SERVICES_HIGH_PRIORITY },
    { 0, DEBIT_NON_EMV, (SAP)Main, (unsigned char)SERVICES_HIGH_PRIORITY }
};


typedef struct Params
{
    char Old_Date[24+1];
    char Old_FmtDate[24+1];
    char Old_Language[24+1];
    char Old_Pabx[24+1];
    char Old_PPad[24+1];
    char Old_PPadType[24+1];
    char Old_ISOreader[24+1];
    char Old_TMSaccess[24+1];
} S_PARAMS;

static char appName[OBJECT_NAME_LEN + 1];
static char fileName[OBJECT_FILE_NAME_LEN + 1];
static const char coldReset[] = "Cold Reset\nFrom ";
static const char warmReset[] = "Warm Reset\nFrom ";
static const char timeToCall[] = "Time to call\nFrom ";
static const char idleMsg[] = "\nPlease Insert\nA Smart Card...";
static const char szDate[] = "Date:%.2s/%.2s/%.2s  %.2s:%.2s\n";
static const char szVolume[] = "ICONS";

static const char *MenuUser[] =
{
    "Function 1",
    "Function 2",
    "Function 3",
    "Function 4",
    "Function 5"
};

int ManageMenu( const char *szTitle, int bRadioButtons, int nDefaultChoice,
                int nItems, const char* Items[] )
{
    FILE *hDisplay;
    int DisplayHeaderStatus;

    // Menu.
    StructList Menu;
    int nY;
    int nMaxX=0;
    int nMaxY=0;

    ENTRY_BUFFER Entry;

    int i;
    int nInput;
    int nReturn;

    hDisplay = fopen( "DISPLAY", "w" );

    // Get Screen size.
    GetScreenSize( &nMaxY, &nMaxX );

    // For the menu height of the menu,
    nY = 0;
    DisplayHeaderStatus=StateHeader(0);            // disable display header

    if ((nDefaultChoice < 0) || (nDefaultChoice >= nItems))
    {
        nDefaultChoice = 0;
    }

    CreateGraphics(_MEDIUM_);

    memset( &Menu, 0, sizeof(Menu) );
    Menu.MyWindow.left   = 0;
    Menu.MyWindow.top    = nY;
    Menu.MyWindow.rigth  = nMaxX - 1;
    Menu.MyWindow.bottom = nMaxY - 1;
    if( nMaxY == 128 )
    {
        Menu.MyWindow.nblines = 10;
    }
    else
    {
        Menu.MyWindow.nblines = 5;
    }

    Menu.MyWindow.fontsize      = _MEDIUM_;
    Menu.MyWindow.type          = _PROPORTIONNEL_;
    Menu.MyWindow.font          = 0;
    Menu.MyWindow.correct       = _ON_;
    Menu.MyWindow.offset        = 0;
    Menu.MyWindow.shortcommand  = _ON_;
    if( bRadioButtons )
    {
        Menu.MyWindow.selected = _ON_;
    }
    else
    {
        Menu.MyWindow.selected = _OFF_;
    }

    Menu.MyWindow.thickness     = 2;
    Menu.MyWindow.border        = _ON_;
    Menu.MyWindow.popup         = _NOPOPUP_;
    Menu.MyWindow.first         = nDefaultChoice;
    Menu.MyWindow.current       = nDefaultChoice;
    Menu.MyWindow.time_out      = 60;
    Menu.MyWindow.title         = (unsigned char*)szTitle;

    for( i = 0; i < nItems; i++ )
    {
        Menu.tab[i] = (unsigned char*)Items[i];
    }

    G_List_Entry((void*)&Menu);
    ttestall(ENTRY, 0);
    nInput = Get_Entry((void*)&Entry);

    switch( nInput )
    {
    case CR_ENTRY_OK:
        nReturn = Entry.d_entry[0];
        break;

    case CR_ENTRY_NOK:
        nReturn = __EXIT_KEY;
        break;

    default:
        nReturn = __BACK_KEY;
        break;
    }
    StateHeader(DisplayHeaderStatus);     // move display header in previous state
    fclose( hDisplay );

    return nReturn;
}

/**
 * Ask application to define its working environment, Manager will select 
 *  common parameters set and adapt its internal processing.
 * \param    no (-I)
 * \param    p1 (-I)
 * \param    param_out (-O) 
 *                          - application_type: TYP_CARTE (French Bank)
 *                                              TYP_HEALTH(French Health)
 *                                              TYP_EXPORT (Export)
 *                          - mask:  Key "F" 031 -> Parameters initialization (0:absent, 1:present)
 *                          - response_number: should be incremented
 *
 * \return FCT_OK
 *
 * \see sdk30.h
 */
int give_your_domain(NO_SEGMENT no, void *p1, S_INITPARAMOUT *param_out)
{

    // Return application domain to Manager
    // Setting parameters initialization
    param_out->returned_state[param_out->response_number].mask = MSK_MDP|MSK_SWIPE|MSK_TYPE_PPAD|MSK_PINPAD|MSK_STANDARD|MSK_LANGUE|MSK_FRMT_DATE|MSK_DATE;
    // International domain
    param_out->returned_state[param_out->response_number].application_type = TYP_EXPORT;
    param_out->response_number++;

    return (FCT_OK);
}

const unsigned char ICON_01[]=
{
0x89,0x50,0x4e,0x47,0x0d,0x0a,0x1a,0x0a,0x00,0x00,0x00,0x0d,0x49,0x48,0x44,0x52,
0x00,0x00,0x00,0x46,0x00,0x00,0x00,0x1e,0x08,0x06,0x00,0x00,0x00,0x91,0xf3,0x68,
0x1e,0x00,0x00,0x00,0x19,0x74,0x45,0x58,0x74,0x53,0x6f,0x66,0x74,0x77,0x61,0x72,
0x65,0x00,0x41,0x64,0x6f,0x62,0x65,0x20,0x49,0x6d,0x61,0x67,0x65,0x52,0x65,0x61,
0x64,0x79,0x71,0xc9,0x65,0x3c,0x00,0x00,0x03,0x20,0x69,0x54,0x58,0x74,0x58,0x4d,
0x4c,0x3a,0x63,0x6f,0x6d,0x2e,0x61,0x64,0x6f,0x62,0x65,0x2e,0x78,0x6d,0x70,0x00,
0x00,0x00,0x00,0x00,0x3c,0x3f,0x78,0x70,0x61,0x63,0x6b,0x65,0x74,0x20,0x62,0x65,
0x67,0x69,0x6e,0x3d,0x22,0xef,0xbb,0xbf,0x22,0x20,0x69,0x64,0x3d,0x22,0x57,0x35,
0x4d,0x30,0x4d,0x70,0x43,0x65,0x68,0x69,0x48,0x7a,0x72,0x65,0x53,0x7a,0x4e,0x54,
0x63,0x7a,0x6b,0x63,0x39,0x64,0x22,0x3f,0x3e,0x20,0x3c,0x78,0x3a,0x78,0x6d,0x70,
0x6d,0x65,0x74,0x61,0x20,0x78,0x6d,0x6c,0x6e,0x73,0x3a,0x78,0x3d,0x22,0x61,0x64,
0x6f,0x62,0x65,0x3a,0x6e,0x73,0x3a,0x6d,0x65,0x74,0x61,0x2f,0x22,0x20,0x78,0x3a,
0x78,0x6d,0x70,0x74,0x6b,0x3d,0x22,0x41,0x64,0x6f,0x62,0x65,0x20,0x58,0x4d,0x50,
0x20,0x43,0x6f,0x72,0x65,0x20,0x35,0x2e,0x30,0x2d,0x63,0x30,0x36,0x30,0x20,0x36,
0x31,0x2e,0x31,0x33,0x34,0x37,0x37,0x37,0x2c,0x20,0x32,0x30,0x31,0x30,0x2f,0x30,
0x32,0x2f,0x31,0x32,0x2d,0x31,0x37,0x3a,0x33,0x32,0x3a,0x30,0x30,0x20,0x20,0x20,
0x20,0x20,0x20,0x20,0x20,0x22,0x3e,0x20,0x3c,0x72,0x64,0x66,0x3a,0x52,0x44,0x46,
0x20,0x78,0x6d,0x6c,0x6e,0x73,0x3a,0x72,0x64,0x66,0x3d,0x22,0x68,0x74,0x74,0x70,
0x3a,0x2f,0x2f,0x77,0x77,0x77,0x2e,0x77,0x33,0x2e,0x6f,0x72,0x67,0x2f,0x31,0x39,
0x39,0x39,0x2f,0x30,0x32,0x2f,0x32,0x32,0x2d,0x72,0x64,0x66,0x2d,0x73,0x79,0x6e,
0x74,0x61,0x78,0x2d,0x6e,0x73,0x23,0x22,0x3e,0x20,0x3c,0x72,0x64,0x66,0x3a,0x44,
0x65,0x73,0x63,0x72,0x69,0x70,0x74,0x69,0x6f,0x6e,0x20,0x72,0x64,0x66,0x3a,0x61,
0x62,0x6f,0x75,0x74,0x3d,0x22,0x22,0x20,0x78,0x6d,0x6c,0x6e,0x73,0x3a,0x78,0x6d,
0x70,0x3d,0x22,0x68,0x74,0x74,0x70,0x3a,0x2f,0x2f,0x6e,0x73,0x2e,0x61,0x64,0x6f,
0x62,0x65,0x2e,0x63,0x6f,0x6d,0x2f,0x78,0x61,0x70,0x2f,0x31,0x2e,0x30,0x2f,0x22,
0x20,0x78,0x6d,0x6c,0x6e,0x73,0x3a,0x78,0x6d,0x70,0x4d,0x4d,0x3d,0x22,0x68,0x74,
0x74,0x70,0x3a,0x2f,0x2f,0x6e,0x73,0x2e,0x61,0x64,0x6f,0x62,0x65,0x2e,0x63,0x6f,
0x6d,0x2f,0x78,0x61,0x70,0x2f,0x31,0x2e,0x30,0x2f,0x6d,0x6d,0x2f,0x22,0x20,0x78,
0x6d,0x6c,0x6e,0x73,0x3a,0x73,0x74,0x52,0x65,0x66,0x3d,0x22,0x68,0x74,0x74,0x70,
0x3a,0x2f,0x2f,0x6e,0x73,0x2e,0x61,0x64,0x6f,0x62,0x65,0x2e,0x63,0x6f,0x6d,0x2f,
0x78,0x61,0x70,0x2f,0x31,0x2e,0x30,0x2f,0x73,0x54,0x79,0x70,0x65,0x2f,0x52,0x65,
0x73,0x6f,0x75,0x72,0x63,0x65,0x52,0x65,0x66,0x23,0x22,0x20,0x78,0x6d,0x70,0x3a,
0x43,0x72,0x65,0x61,0x74,0x6f,0x72,0x54,0x6f,0x6f,0x6c,0x3d,0x22,0x41,0x64,0x6f,
0x62,0x65,0x20,0x50,0x68,0x6f,0x74,0x6f,0x73,0x68,0x6f,0x70,0x20,0x43,0x53,0x35,
0x20,0x57,0x69,0x6e,0x64,0x6f,0x77,0x73,0x22,0x20,0x78,0x6d,0x70,0x4d,0x4d,0x3a,
0x49,0x6e,0x73,0x74,0x61,0x6e,0x63,0x65,0x49,0x44,0x3d,0x22,0x78,0x6d,0x70,0x2e,
0x69,0x69,0x64,0x3a,0x37,0x39,0x43,0x35,0x33,0x32,0x38,0x42,0x30,0x39,0x33,0x36,
0x31,0x31,0x45,0x31,0x38,0x37,0x43,0x37,0x39,0x37,0x41,0x45,0x32,0x34,0x33,0x32,
0x36,0x42,0x38,0x37,0x22,0x20,0x78,0x6d,0x70,0x4d,0x4d,0x3a,0x44,0x6f,0x63,0x75,
0x6d,0x65,0x6e,0x74,0x49,0x44,0x3d,0x22,0x78,0x6d,0x70,0x2e,0x64,0x69,0x64,0x3a,
0x37,0x39,0x43,0x35,0x33,0x32,0x38,0x43,0x30,0x39,0x33,0x36,0x31,0x31,0x45,0x31,
0x38,0x37,0x43,0x37,0x39,0x37,0x41,0x45,0x32,0x34,0x33,0x32,0x36,0x42,0x38,0x37,
0x22,0x3e,0x20,0x3c,0x78,0x6d,0x70,0x4d,0x4d,0x3a,0x44,0x65,0x72,0x69,0x76,0x65,
0x64,0x46,0x72,0x6f,0x6d,0x20,0x73,0x74,0x52,0x65,0x66,0x3a,0x69,0x6e,0x73,0x74,
0x61,0x6e,0x63,0x65,0x49,0x44,0x3d,0x22,0x78,0x6d,0x70,0x2e,0x69,0x69,0x64,0x3a,
0x37,0x39,0x43,0x35,0x33,0x32,0x38,0x39,0x30,0x39,0x33,0x36,0x31,0x31,0x45,0x31,
0x38,0x37,0x43,0x37,0x39,0x37,0x41,0x45,0x32,0x34,0x33,0x32,0x36,0x42,0x38,0x37,
0x22,0x20,0x73,0x74,0x52,0x65,0x66,0x3a,0x64,0x6f,0x63,0x75,0x6d,0x65,0x6e,0x74,
0x49,0x44,0x3d,0x22,0x78,0x6d,0x70,0x2e,0x64,0x69,0x64,0x3a,0x37,0x39,0x43,0x35,
0x33,0x32,0x38,0x41,0x30,0x39,0x33,0x36,0x31,0x31,0x45,0x31,0x38,0x37,0x43,0x37,
0x39,0x37,0x41,0x45,0x32,0x34,0x33,0x32,0x36,0x42,0x38,0x37,0x22,0x2f,0x3e,0x20,
0x3c,0x2f,0x72,0x64,0x66,0x3a,0x44,0x65,0x73,0x63,0x72,0x69,0x70,0x74,0x69,0x6f,
0x6e,0x3e,0x20,0x3c,0x2f,0x72,0x64,0x66,0x3a,0x52,0x44,0x46,0x3e,0x20,0x3c,0x2f,
0x78,0x3a,0x78,0x6d,0x70,0x6d,0x65,0x74,0x61,0x3e,0x20,0x3c,0x3f,0x78,0x70,0x61,
0x63,0x6b,0x65,0x74,0x20,0x65,0x6e,0x64,0x3d,0x22,0x72,0x22,0x3f,0x3e,0x99,0xc3,
0x68,0x66,0x00,0x00,0x05,0xc0,0x49,0x44,0x41,0x54,0x78,0xda,0xe4,0x99,0x69,0x4c,
0x1c,0x55,0x1c,0xc0,0xff,0xf3,0x96,0xdd,0xe5,0x2c,0xbb,0x1b,0x40,0x20,0xda,0x56,
0xc1,0x90,0x98,0x12,0xd0,0x72,0xc4,0xa0,0x6d,0xb0,0x50,0x63,0x10,0xf9,0x50,0x52,
0x8b,0x12,0x63,0x6b,0x22,0x18,0x93,0x6a,0x2a,0xe1,0x5b,0x63,0x2a,0x92,0xe8,0x17,
0x48,0x08,0xd1,0xb6,0x7e,0xa4,0x57,0x2c,0xa6,0xd6,0xd6,0x14,0x0f,0x48,0xa0,0x60,
0xb0,0x10,0x8e,0x50,0xae,0x14,0xb9,0x4a,0xb9,0xbb,0x6c,0xb9,0x77,0xe7,0x78,0xbe,
0xff,0x63,0x67,0x1c,0x40,0x4d,0x3f,0x74,0xa0,0xae,0xff,0xf0,0x98,0x37,0xb3,0x6f,
0x8e,0xf7,0x9b,0xff,0xf9,0x46,0x88,0x49,0xcf,0x03,0x9d,0x08,0xde,0x2d,0x71,0x76,
0xfc,0x94,0x41,0x81,0xe6,0x02,0xa5,0x2f,0xb0,0xfd,0x04,0xd6,0x4c,0xe0,0x3b,0xd2,
0x06,0x82,0xd0,0x26,0x80,0x50,0xed,0x48,0x7c,0xf5,0x57,0xb6,0xaf,0x78,0x8f,0x53,
0x0d,0x84,0x0e,0x0c,0x42,0x21,0x73,0xb7,0xeb,0x9e,0x55,0x24,0xcf,0x59,0xaa,0x28,
0x2f,0xc3,0xff,0x40,0x04,0x42,0x6e,0x12,0x3f,0xcb,0xfb,0xf6,0x3d,0xaf,0xdc,0xf1,
0x02,0xa2,0x7a,0x30,0x1c,0x8a,0xb3,0xab,0x76,0x9f,0x22,0xba,0xbf,0x63,0x7d,0x3b,
0xd5,0xf8,0xd1,0xbf,0x30,0xfa,0x0a,0x0c,0xf5,0xbf,0xa0,0x99,0xc8,0x1c,0x31,0x5b,
0x0f,0x39,0xe2,0x0f,0x34,0xa8,0x70,0x10,0x0c,0x87,0xe2,0xea,0xa9,0x8f,0x93,0xdd,
0xcb,0x4d,0x94,0x52,0x1b,0x6b,0xf0,0x7a,0x76,0x36,0x7c,0x74,0xfc,0x38,0xec,0xdd,
0xbb,0x17,0x4c,0x26,0x93,0x4f,0x81,0x91,0x65,0x19,0x3a,0x3a,0x3a,0xa0,0xac,0xbc,
0x1c,0xae,0x5f,0xbb,0xc6,0xac,0x4a,0xc0,0xe6,0x32,0x59,0x03,0xd3,0x6c,0xcf,0xed,
0xef,0x47,0x38,0x44,0xf5,0x29,0x54,0x72,0x7f,0xa3,0x42,0xf9,0xbc,0xb4,0x14,0xce,
0x9f,0x3b,0x07,0x29,0x29,0x29,0x3e,0x07,0x05,0x05,0xe7,0x84,0x2f,0x1c,0xe7,0x88,
0x73,0xc5,0x39,0xf3,0xb9,0x33,0x06,0xc8,0x42,0x35,0x25,0xd3,0x5c,0x57,0x6d,0xa6,
0x2c,0xba,0x6f,0xe0,0x80,0xcc,0x83,0x07,0xa1,0xfa,0xf2,0x65,0x7e,0x81,0x95,0x95,
0x15,0x98,0x9f,0x9f,0x07,0xb7,0xdb,0xed,0x93,0xfe,0xc5,0x62,0xb1,0x40,0x48,0x48,
0x08,0xe4,0xe7,0xe7,0x43,0x5d,0x5d,0x1d,0xd7,0x1c,0x93,0xd9,0xfa,0x9a,0x3d,0xfe,
0xc0,0x2f,0x7e,0x38,0xc0,0xcf,0x44,0x8e,0x48,0xe2,0x9a,0x4b,0xf9,0xe4,0xc4,0x09,
0x7e,0x92,0xd3,0xe9,0x84,0x07,0x0f,0x1e,0x70,0x9a,0xbe,0x2a,0xa2,0x28,0xf2,0x17,
0x7f,0xec,0xd8,0x7b,0x50,0xcb,0xc0,0xa8,0x2c,0xd8,0x86,0x83,0x21,0x8a,0x2c,0xa7,
0x23,0x15,0x84,0x90,0x98,0x98,0x08,0xcb,0xcb,0xcb,0x70,0xff,0xfe,0xfd,0x2d,0x81,
0xd2,0xd2,0xd2,0x02,0xd5,0xd5,0xd5,0x30,0x3c,0x3c,0xcc,0xf7,0x93,0x93,0x93,0x21,
0x37,0x37,0x17,0x76,0xef,0xde,0x6d,0xf8,0xbd,0x15,0x45,0x01,0x49,0x92,0x21,0x3c,
0x22,0x82,0xcf,0x95,0x79,0x1a,0xe0,0x2c,0x18,0x13,0x0e,0x46,0x92,0xc4,0x28,0xae,
0x2f,0xec,0x2f,0x20,0x20,0x00,0x46,0x46,0x46,0xd8,0x09,0x92,0xe1,0x60,0x6a,0x6a,
0x6a,0xa0,0xaa,0xaa,0x6a,0x13,0xa8,0xde,0xde,0x5e,0x28,0x2e,0x2e,0x86,0x98,0x98,
0x18,0xc3,0xc1,0x88,0xa2,0xc4,0x4d,0x88,0x9b,0x8b,0x40,0x61,0x8d,0xc5,0x1a,0x18,
0x81,0x01,0x30,0xeb,0x11,0x2c,0x2e,0x2e,0x72,0xcf,0x6d,0x24,0x98,0xd9,0xd9,0xd9,
0x75,0x50,0xd2,0xd3,0xd3,0x61,0x7c,0x7c,0x1c,0xfa,0xfb,0xfb,0xf9,0xfd,0x4f,0x9f,
0x3e,0x0d,0x15,0x15,0x15,0xbc,0x6f,0x58,0x74,0xe2,0x60,0x44,0x0e,0x47,0xcd,0x4e,
0x90,0x05,0x32,0xf1,0xd3,0x0f,0x54,0x31,0x78,0x3c,0x1e,0xd5,0x53,0x1b,0xf6,0x50,
0x57,0xae,0x5c,0xd1,0xfa,0xd1,0xd1,0xd1,0x50,0x56,0x56,0x06,0x7d,0x7d,0x7d,0x90,
0x97,0xb7,0x96,0x70,0x22,0xa4,0xce,0xce,0x4e,0xd8,0xb5,0x6b,0x97,0xa1,0x60,0xd0,
0x94,0xb8,0x75,0xe8,0xd2,0x7e,0xee,0x6b,0xfe,0xc9,0x29,0x19,0x0d,0xa6,0xad,0xad,
0x4d,0xeb,0x27,0x25,0x25,0xf1,0xc8,0xe7,0x72,0xb9,0x20,0x2c,0x2c,0x8c,0x6b,0x13,
0x4a,0x63,0x63,0x23,0x24,0x24,0x24,0xc0,0xcc,0xcc,0x8c,0x71,0x3e,0x86,0x69,0x0b,
0xce,0x77,0xa3,0x6c,0x0b,0x18,0x8c,0x78,0x98,0x0a,0xe8,0x35,0x06,0xa1,0xe0,0x7d,
0xed,0x76,0xbb,0x06,0x06,0xcd,0xca,0x66,0xb3,0x71,0xed,0x31,0xd2,0xc7,0x3c,0x36,
0x60,0xa6,0xa7,0xa7,0x37,0x1d,0xc3,0x48,0x88,0xf7,0xc5,0x87,0x55,0x05,0x81,0x04,
0x05,0x05,0xfd,0xed,0x83,0x3f,0x32,0x30,0xcc,0x8c,0x24,0xe9,0x21,0xc1,0x74,0x77,
0x77,0x1b,0xea,0x7c,0x27,0x27,0x27,0x37,0x1d,0x9b,0x9a,0x9a,0x82,0xae,0xae,0x2e,
0x58,0x5a,0x5a,0x5a,0x77,0xdc,0xdf,0xdf,0x9f,0x1f,0x37,0x0a,0x0c,0xce,0x13,0xfd,
0xcc,0x46,0x21,0xdb,0x95,0x71,0x3e,0x8c,0x60,0x56,0xba,0x5d,0xb2,0x2d,0x60,0x1c,
0x0e,0xc7,0xba,0xfd,0x85,0x85,0x05,0xad,0x8f,0x11,0x51,0x95,0xb8,0xb8,0xb8,0x6d,
0x2b,0x47,0xc8,0x76,0xbd,0x91,0xc8,0xc8,0x48,0xad,0xdf,0xda,0xda,0x0a,0x56,0xab,
0x95,0x43,0x41,0xc7,0xac,0x8f,0x56,0x46,0x45,0xa4,0xc7,0x16,0x4c,0x6c,0x6c,0xac,
0xd6,0xc7,0xe8,0x73,0xeb,0xd6,0x2d,0xde,0xf4,0x92,0x9d,0x9d,0x0d,0x63,0x63,0x63,
0x86,0x3e,0x07,0xfd,0x37,0x30,0x02,0x21,0x9e,0x75,0x83,0xb7,0xa0,0x46,0x42,0x30,
0xfa,0x94,0x1f,0x33,0xdd,0x81,0x81,0x01,0x6d,0xbf,0xb0,0xb0,0x90,0x87,0x71,0x2c,
0x0f,0x0c,0x05,0x83,0xd1,0x57,0x87,0x87,0x95,0x07,0xa2,0x06,0xc6,0x6c,0xb6,0xcc,
0xaa,0x2b,0x5b,0x58,0x6d,0x6e,0x55,0x45,0x9d,0x9a,0x9a,0x0a,0x39,0x39,0x39,0x9b,
0x1c,0x6e,0x51,0x51,0x11,0x14,0x14,0x14,0x40,0x73,0x73,0x33,0x7f,0x1e,0xa3,0x80,
0x28,0x08,0x45,0xa1,0xb0,0xba,0xea,0xd6,0xb2,0x5e,0xb3,0xd9,0x3a,0xab,0x86,0x6b,
0xba,0x23,0x34,0xb4,0xc7,0xbd,0xba,0x12,0x4d,0xd9,0xaf,0xb7,0x59,0xa8,0xc6,0x30,
0xa6,0xc2,0xe1,0x05,0x96,0xc1,0xeb,0x21,0x95,0x95,0x95,0xdc,0xc7,0xe8,0xb3,0xe0,
0x86,0x86,0x06,0x68,0x6f,0x6f,0x37,0x0e,0x0a,0x86,0x6a,0x2c,0x07,0x58,0xb8,0x9e,
0x98,0x18,0xd7,0x96,0x39,0x77,0xd8,0x42,0xbb,0x71,0x08,0x82,0x51,0xa2,0x9f,0x7c,
0xea,0xc6,0xcc,0xd4,0x54,0x06,0x5a,0xdc,0x67,0xa7,0x4e,0x41,0x56,0x56,0x16,0x73,
0x84,0xde,0xa4,0x47,0x58,0x5f,0x43,0xc0,0x23,0x06,0xb5,0xcc,0x32,0xe0,0xdf,0x99,
0x6f,0x41,0x30,0x11,0xe1,0xe1,0x30,0x34,0x34,0x04,0x77,0x8d,0xf0,0x2b,0xde,0x17,
0xcd,0x0b,0x45,0xa6,0x25,0xb2,0x22,0x6b,0x75,0x52,0x43,0x7d,0x83,0x3a,0x39,0x40,
0x16,0x0c,0x93,0xc2,0xc1,0xbc,0x53,0xf0,0xf1,0xb7,0x27,0x4f,0x14,0x7c,0xb8,0xb4,
0xb8,0xf8,0x4c,0x63,0xd3,0x6f,0x10,0x14,0x1c,0x02,0x29,0x29,0xc9,0xde,0x95,0x88,
0xad,0x31,0x2b,0x8c,0x48,0xfa,0xb0,0x6d,0x94,0xa7,0xa5,0xde,0xc4,0x4e,0x6d,0xa8,
0x99,0x63,0xf7,0xee,0x01,0x21,0x02,0x04,0x06,0x07,0x0d,0x22,0x8b,0x2f,0xce,0x5c,
0x50,0xf8,0xd2,0x26,0x9a,0xd6,0x4b,0x31,0xa1,0x6f,0x5e,0xad,0xbe,0x74,0x56,0x96,
0x15,0x0b,0xda,0xde,0xce,0x9d,0x3b,0xf9,0xa2,0x51,0x54,0x54,0x14,0x4f,0xcb,0x7d,
0x65,0x25,0x0f,0x67,0xc1,0x14,0x00,0xc6,0x27,0x26,0xa0,0xb5,0xa5,0x85,0x47,0x3d,
0x82,0x4b,0x9a,0x26,0xe2,0x79,0xe3,0xd0,0xe1,0xc2,0xa6,0xc1,0x85,0x8b,0xf8,0x9e,
0xb8,0xc6,0x60,0x05,0x1e,0x93,0xf0,0xe2,0x8d,0x7d,0x73,0xce,0x92,0xfa,0xda,0x9f,
0x4f,0x32,0x3d,0xb3,0x8c,0x8e,0x8e,0xc2,0xe8,0xc8,0x88,0xba,0x46,0xe1,0x53,0x4b,
0x9a,0xfc,0xab,0x80,0xd7,0x2d,0x20,0x14,0xc2,0xa0,0xec,0xcf,0x38,0x58,0x12,0x9b,
0x98,0xf6,0x63,0xd3,0x60,0x0d,0xd6,0x07,0xd4,0xe4,0x78,0x3a,0x9e,0x8f,0xe9,0xec,
0x1d,0x10,0xdf,0x3e,0x72,0xf8,0x8e,0x2d,0x24,0x78,0x74,0xf0,0x8f,0x81,0x78,0x59,
0x96,0x42,0xb9,0x7f,0xf1,0x9e,0x2c,0xf8,0x48,0xe3,0x73,0x21,0xde,0x3e,0xdb,0xfa,
0x07,0x04,0xde,0xcd,0x39,0x74,0xf8,0xd3,0xb4,0xcc,0xec,0x4b,0x67,0x2e,0xfe,0x80,
0xd9,0x25,0x82,0x51,0x10,0x8c,0xa6,0x65,0xcd,0x1d,0x3d,0xab,0x99,0x19,0x19,0x83,
0xef,0x1e,0x3d,0x5a,0x3f,0x36,0x36,0xea,0x5a,0x59,0x5a,0x0e,0xf4,0x78,0xdc,0x61,
0xc0,0xaf,0xe7,0x43,0x70,0x08,0x91,0x6c,0x36,0x47,0xd7,0x9e,0xc4,0xe7,0x2f,0x96,
0x7c,0x59,0x5e,0x0a,0x01,0xf6,0x9b,0x5f,0x9d,0xff,0x1e,0xa1,0x48,0x5e,0x0b,0xda,
0xfc,0x89,0x16,0xdb,0x13,0x61,0x0e,0xbf,0x0f,0xde,0xca,0x89,0x70,0xd8,0x42,0xc2,
0xfd,0x2d,0x96,0x1d,0x6e,0x49,0x34,0x29,0xb2,0x22,0xc8,0x0a,0x15,0xa8,0xa2,0x08,
0xff,0x49,0xf3,0x21,0x84,0x9a,0x88,0x40,0x99,0xd9,0x50,0xab,0x9f,0x59,0x5e,0xf5,
0x78,0xe6,0x9d,0xae,0x85,0x99,0xaf,0x2f,0x5c,0x9d,0x9e,0x9a,0x75,0xaa,0x40,0x36,
0x7d,0xa2,0x5d,0x77,0x0d,0x5d,0x23,0xba,0xad,0x2f,0x89,0x0a,0x40,0xdd,0xd2,0x8d,
0xd5,0xc1,0x9f,0x02,0x0c,0x00,0xd9,0x8b,0x23,0x10,0xff,0xc0,0xa3,0x55,0x00,0x00,
0x00,0x00,0x49,0x45,0x4e,0x44,0xae,0x42,0x60,0x82,
};

// Create a disk to store ICONS
int CreateDisk(char *Nom)
{
  S_FS_PARAM_CREATE ParamCreat;
  int               Retour;
  unsigned long     TailleDisk;
  char              FilePath_L[33];

  /* ************************************* */
  /* creation du disque            */
  /* ************************************* */
  strcpy(ParamCreat.Label, Nom);
  ParamCreat.Mode         = FS_WRITEONCE;
  ParamCreat.IdentZone    = FS_WO_ZONE_DATA;
  ParamCreat.AccessMode   = FS_WRTMOD;
  ParamCreat.NbFichierMax = 10+2; // 10 fichiers + 2 fichiers de service
  TailleDisk              = 10*1024*20; // 10 fichiers de 20 Ko

  // Mount ....
  sprintf(FilePath_L,"/%s",Nom);
  Retour = FS_mount (FilePath_L,&ParamCreat.Mode);
  if (Retour != FS_OK)
  {
    Retour=FS_dskcreate(&ParamCreat,&TailleDisk);
  }
  return(Retour);
}

// Write my icon file into disk
void WriteIconFile(char *data,unsigned long size,char *name,char *volume)
{
  S_FS_FILE         *Handle;
  char               FilePath_L[33];
  
  sprintf(FilePath_L,"/%s/%s",volume,name);
  FS_unlink(FilePath_L);
  Handle = FS_open(FilePath_L,"a");
  if (Handle)
  {
    FS_write((char *)data,1,size,Handle);
    FS_close(Handle);
  }
}

/**
 * Initialize data and create disks, eventually ends interrupted transaction
 *  by returning S_TRANS_OUT.
 * \param    no (-I) 
 * \param    p1 (-I)
 * \param    param_out (-O) Eventually ends interrupted transaction
 *
 * \return FCT_OK
 *
 * \see sdk30.h
 */
int after_reset(NO_SEGMENT no, void *p1, S_TRANSOUT *param_out)
{
    FILE *hDisplay;
    unsigned char chgt;
    TYPE_CHGT  type;

    // Reset management
    hDisplay  = fopen( "DISPLAY",  "w" );  // Open display driver

    first_init(no, &chgt, (unsigned char *)&type);          // New software loaded ?
    if (chgt==0xFF)                        // Yes, just loaded with first execution
    {

        printf(coldReset);
        printf(appName);
        raz_init(no);                      // Reset downloading indicator
    }
    else                                   // No, already loaded and executed
    {
        printf(warmReset);
        printf(appName);
    }

    ttestall(0, 2*100);                    // Wait for 2s.
    fclose( hDisplay  );                   // Close display driver
    
    CreateDisk((char *)szVolume);
    WriteIconFile((char *)ICON_01,sizeof(ICON_01),(char *)"ICON_01.PNG",(char *)szVolume);

    return FCT_OK;
}

/**
 * Report application name to Manager.
 * \param    no (-I) 
 * \param    p1 (-I) 
 * \param    param_out (-O) 
 *                          - appname: Application name 
 *                          - no: Application number
 *                          - response_number: should be incremented
 *
 * \return FCT_OK
 *
 * \see sdk30.h
 */
int is_name(NO_SEGMENT no, void *p1, S_ETATOUT *param_out)
{
  // Report application name to Manager cannot return the family name
  // because the T_APPNAME type used in the "is_name" function is too short to store
  // the FAMILY NAME (T_APPNAME length = 12+1 FAMILY NAME length =15+1)
  // we use the binary name instead (without extension, and whose length is 11+1)

  memset(param_out->returned_state[param_out->response_number].appname,0, sizeof(param_out->returned_state[param_out->response_number].appname));
  strncpy(param_out->returned_state[param_out->response_number].appname, fileName, sizeof(param_out->returned_state[param_out->response_number].appname) - 1);
  param_out->returned_state[param_out->response_number].no_appli = no;
  param_out->response_number++;

  return (FCT_OK);
}

/**
 * Report extended application name to Manager.
 * \param    no (-I) 
 * \param    p1 (-I) 
 * \param    param_out (-O) 
 *                          - appname: Application name 
 *                          - iconname: Icon name 
 *                          - no: Application number
 *                          - response_number: should be incremented
 *
 * \return FCT_OK
 *
 * \see sdk30.h
 */
int is_name_extended(NO_SEGMENT no,void *p1,S_ETATOUT_EXTENDED *param_out)
{
  // Report extended application name to Manager cannot return the family name
  // Report icon name to Manager 

  memset(param_out->returned_state[param_out->response_number].appname,0, sizeof(param_out->returned_state[param_out->response_number].appname));
  memset(param_out->returned_state[param_out->response_number].iconname,0, sizeof(param_out->returned_state[param_out->response_number].iconname));
  strcpy(param_out->returned_state[param_out->response_number].appname, appName);
  strcpy(param_out->returned_state[param_out->response_number].iconname,"ICON_01.PNG");
  param_out->returned_state[param_out->response_number].no_appli = no;
  param_out->response_number++;

  return (FCT_OK);
}

/**
 * Report extended application option.
 * \param    no (-I) 
 * \param    p1 (-I) 
 * \param    param_out (-O) 
 *                          - appname: volume to search for Icon 
 *                          - no: Application number
 *                          - response_number: should be incremented
 *
 * \return FCT_OK
 *
 * \see sdk30.h
 */
int give_your_specific_context(NO_SEGMENT no,void *p1,S_SPECIFIC_CONTEXT *param_out)
{
  /* Used to specify the list of parameters */
  param_out->returned_state[param_out->response_number].mask             = 0;
  /* My type of application */
  param_out->returned_state[param_out->response_number].type             = 1;
  /* CLESS */
  param_out->returned_state[param_out->response_number].support          = 0;
  /* CAM */
  param_out->returned_state[param_out->response_number].cam              = 0;
  /* I'am CGUI */
  param_out->returned_state[param_out->response_number].cgui             = 0;
  /* Used to put the volume to search for Icon */
  strcpy((char *)param_out->returned_state[param_out->response_number].appname,szVolume);
  param_out->returned_state[param_out->response_number].no_appli = no;
  param_out->response_number++;
  return (FCT_OK);
}

/**
 * Report application state initialize or not to Manager.
 * \param    no (-I) 
 * \param    p1 (-I) 
 * \param    param_out (-O) 
 *                          - response: REP_OK (Initialized)
 *                                      REP_KO (Not initialized) 
 * 
 * \return FCT_OK
 *
 * \see sdk30.h
 */
int is_state(NO_SEGMENT no, void *p1, S_ETATOUT *param_out)
{
    int retour;

    // Return application state
    param_out->returned_state[param_out->response_number].state.response = REP_OK;
    retour = is_name (no, PT_NULL, param_out);

    return (retour);
}

/**
 * Allows the application to display its idle message when Manager goes back 
 *  to idle (the application should have the higher priority).
 * \param    no (-I) 
 * \param    p1 (-I) 
 * \param    p2 (-I) 
 *
 * \return FCT_OK
 *
 * \see sdk30.h
 */
int idle_message (NO_SEGMENT no, void *p1, void *p2)
{
    FILE *hDisplay;
    int nFont;
    char idleMessage[256];

    // Idle message management
    hDisplay = fopen("DISPLAY","w");        // Open display driver.
    nFont = GetDefaultFont();               // Retrieve default font

    CreateGraphics(_LARGE_);                // Create graphic font
    strcpy(idleMessage,appName);
    strcat(idleMessage,idleMsg);
    _DrawString((char*) idleMessage,  0, 20, _OFF_);
    PaintGraphics();                        // Display idle message

    SetDefaultFont(nFont);                  // Restore default font
    fclose(hDisplay);                       // Close display driver

    return FCT_OK;
}

/**
 * It's activated when pressing on "F" key to select the right application 
 *  to go on menu.
 * \param    no (-I) 
 * \param    p1 (-I) 
 * \param    p2 (-I) 
 *
 * \return FCT_OK
 *
 * \see sdk30.h
 * 
 * \note Other prototype variant 'int more_function_ext(NO_SEGMENT no, S_ETATOUT *in, void *out)'
 *       can be used with INCENDO.
 *       This other prototype is used if the application manages more than one application name.
 *       The 'S_ETATOUT' structure allows to know the name selected by the user after pressing the "F" key.
 *       This new prototype can be used with SDK version >= 6.5.
 */
int more_function( NO_SEGMENT no, void *p1, void *p2 )
{
    FILE *hDisplay;
    int bContinue=1;

    // Menu management
    hDisplay =fopen("DISPLAY", "w");                                  // Open display driver
    do
    {
        switch(ManageMenu(appName, 0, 0, NUMBER_OF_ITEMS(MenuUser), MenuUser))
        {
        case 0: printf("Function1\nRunning..."); bContinue=0; break;  // Function1 selected
        case 1: printf("Function2\nRunning..."); bContinue=0; break;  // Function2 selected
        case 2: printf("Function3\nRunning..."); bContinue=0; break;  // Function3 selected
        case 3: printf("Function4\nRunning..."); bContinue=0; break;  // Function4 selected
        case 4: printf("Function5\nRunning..."); bContinue=0; break;  // Function5 selected
        default: bContinue=2; break;                                  // Abort key pressed
        }
    } while(bContinue==1);

    if (bContinue!=2)
    {
        ttestall(0, 2*100);                                           // Wait for 2s.
    }
    fclose(hDisplay);                                                 // Close display driver

    return FCT_OK;
}

/**
 * It's activated when key is pressed and terminal is in idle mode.
 * \param    noappli 
 * \param    key_in (I-)
 *                       - keycode: Key pressed. 
 * \param    key_out (-O)
 *                       - keycode: Key pressed, new key, 0=disable.
 * 
 * \return FCT_OK
 *
 * \see sdk30.h
 */
int keyboard_event(NO_SEGMENT noappli,S_KEY *key_in,S_KEY *key_out)
{
    // Keyboard management
    switch (key_in->keycode)
    {
    case N0: case N1: case N2: case N3: case N4:
    case N5: case N6: case N7: case N8: case N9:
    case T_VAL : case T_POINT :
        key_out->keycode = 0;               // Inhibit these keys to Manager for International domain
        break;
    case F1 : case F2 : case F3 : case F4 :
    case T_CORR : case T_ANN : case NAVI_CLEAR : case NAVI_OK :
    case UP : case DOWN :
    case T_F :                              // do not filter F key and return the same key !
        key_out->keycode=key_in->keycode;   // Return the same key value for keys above !
        break;
    default :
        key_out->keycode=key_in->keycode;
        break;
    }

    return (FCT_OK);
}

/**
 * It's activated on "F" key: Consultation->State. 
 *  To print terminal content.  
 * \param    no (-I) 
 * \param    p1 (-I) 
 * \param    p2 (-I) 
 *
 * \return FCT_OK
 *
 * \see sdk30.h
 */
int state (NO_SEGMENT no, void *p1, void *p2)
{
    DATE date;
    object_info_t infos;
    FILE     *hPrinter;

    // Print application info
    ObjectGetInfo(OBJECT_TYPE_APPLI, no, &infos);       // Retrieve application info

    hPrinter=fopen( "PRINTER", "w-*" );                 // Open printer driver
    if (hPrinter!=NULL)
    {
        pprintf("\x1b""E%s\n""\x1b""F",appName);        // Print application name
        pprintf("         STATE         \n"
                "Application used as\n"
                "IngeDev Template\n\n");
        read_date(&date);                               // Print date and time
        pprintf(szDate, date.day, date.month, date.year, date.hour, date.minute);
        pprintf("File    : %s\n",infos.file_name);      // Print application file name
        pprintf("CRC     : %04x\n",infos.crc);          // Print application CRC
        ttestall(PRINTER, 0);

        fclose(hPrinter);                               // Close printer driver
    }

    return FCT_OK;
}

/**
 * It's activated on "F" key: Consultation->Transactions. 
 *  To print transactions total receipt. 
 * \param    no (-I) 
 * \param    p1 (-I) 
 * \param    p2 (-I) 
 *
 * \return FCT_OK
 *
 * \see sdk30.h
 */
int consult (NO_SEGMENT no, void *p1, void *p2)
{
    DATE date;
    FILE *hPrinter;

    // Print daily totals
    hPrinter=fopen("PRINTER", "w-*");                    // Open printer driver
    if (hPrinter!=NULL)
    {
        pprintf("\x1b""E%s\n""\x1b""F", appName);        // Print application name
        pprintf("        CONSULT        \n"
                "Print daily totals here\n"
                "Number of Debit/Credit \n"
                "Totals of Debit/Credit \n"
                "Number of Cancel\n\n");
        read_date(&date);                                // Print date and time
        pprintf(szDate, date.day, date.month, date.year, date.hour, date.minute);

        ttestall(PRINTER, 3*100);
        fclose(hPrinter);                                // Close printer driver
    }

    return FCT_OK;
}

/**
 * It's activated on "F" key: Consultation->Call->Planning of Call. 
 *  To print call schedule receipt. 
 * \param    no (-I) 
 * \param    p1 (-I) 
 * \param    p2 (-I) 
 *
 * \return FCT_OK
 *
 * \see sdk30.h
 */
int mcall (NO_SEGMENT no, void *p1, void *p2)
{
    DATE date;
    FILE *hPrinter;

    // Print call schedule
    hPrinter=fopen("PRINTER", "w-*");                     // Open printer driver
    if (hPrinter!=NULL)
    {
        pprintf("\x1b""E%s\n""\x1b""F", appName);         // Print application name
        pprintf("         MCALL         \n"
                "Planning of call here  \n"
                "Time release batch     \n"
                "Time loading parameters\n"
                "Time loading hotlist\n\n");
        read_date(&date);                                 // Print date and time
        pprintf(szDate, date.day, date.month, date.year, date.hour, date.minute);

        ttestall(PRINTER, 3*100);
        fclose(hPrinter);                                 // Close printer driver
    }

    return FCT_OK;
}

/**
 * Do you need the peripherals at the next call of time_function()?.
 *  It's call every minute.
 * \param    no (-I) 
 * \param    p1 (-I) 
 * \param    param_out (-O) 
 *                          - response: REP_OK (Manager closes all peripherals)
 *                                      REP_KO (Manager keeps all peripherals opened) 
 * 
 * \return FCT_OK
 *
 * \see sdk30.h
 */
int is_time_function(NO_SEGMENT no, void *p1, S_ETATOUT *param_out)
{
    int retour;

    // Peripherals needed?
    param_out->returned_state[param_out->response_number].state.response=REP_OK;
    retour = is_name (no, PT_NULL, param_out);

    return(FCT_OK);
}

/**
 * Allow application to execute its own periodical process. 
 *  It's call every minute. 
 * \param    no (-I)
 * \param    p1 (-I) 
 * \param    p2 (-I) 
 *
 * \return FCT_OK
 *
 * \see sdk30.h
 */
int time_function(NO_SEGMENT no, void *p1, void *p2)
{
    // Periodical function in progress
    fopen("DISPLAY","w");                 // Open display driver
    printf(timeToCall);
    printf(appName);

    ttestall(0, 1*100);
    fclose(stdout());                     // Close display driver

    return (FCT_OK);
}

/**
 * It's activated on "F" key: Initialization->Parameters->List.
 *  Each time Manager wants to change its own parameters.
 * \param    no (-I) 
 * \param    p1 (-I) 
 * \param    param_out (-O)
 *                          - mask: Key "F" 031 -> Parameters modification (0:accepting, 1:refusing)
 *
 * \return FCT_OK
 *
 * \see sdk30.h
 */
int is_change_init(NO_SEGMENT no, void *p1, S_ETATOUT *param_out)
{
    S_ETATOUT etatout;
    int       retour;
    memcpy(&etatout, param_out, sizeof(etatout));

    // accept all
    etatout.returned_state[etatout.response_number].state.mask=0;
    memcpy(param_out,&etatout,sizeof(etatout));
    retour = is_name (no, PT_NULL, param_out);
    return(FCT_OK);
}

/**
 * It's activated on "F" key: Initialization->Parameters->List.
 *  Each time Manager changed its own parameters.
 * \param    noappli (I-)
 * \param    param_in (I-)
 *                         - mask: Key "F" 031 -> Parameters modification (0:not modified, 1:modified)
 * \param    p2 (-I) 
 *
 * \return FCT_OK
 *
 * \see sdk30.h
 */
int modif_param(NO_SEGMENT noappli, S_MODIF_P *param_in, void *p2)
{
    S_MODIF_P param_changed;

    memcpy(&param_changed, param_in,sizeof(param_changed));
    fopen("DISPLAY","w");
    printf("MODIF_PARAM\n%04x",(int)param_changed.etatout.returned_state[0].state.mask);
    ttestall(0,200);
    fclose(stdout());
    return(FCT_OK);
}

/**
 * It's activated each time Manager wants to run a downloading session (local or remote).
 *  "F" key: Evolution->Load->Local or Evolution->Remote Load
 * \param    no (-I) 
 * \param    p1 (-I) 
 * \param    param_out (-O) 
 *                          - response: REP_OK (application authorizes donwloading process)
 *                                      REP_KO (application refuses any downloading process)
 *  
 * \return FCT_OK
 *
 * \see sdk30.h
 */
int is_evol_pg(NO_SEGMENT no, void *p1, S_ETATOUT *param_out)
{
    int retour;

    // Downloading process allowed?
    param_out->returned_state[param_out->response_number].state.response=REP_OK;
    retour = is_name (no, PT_NULL, param_out);

    return(FCT_OK);
}

/**
 * It's activated each time Manager wants to delete an application.
 *  "F" key: Deletion
 * \param    no (-I) 
 * \param    p1 (-I) 
 * \param    param_out (-O)
 *                          - response: DEL_YES (application authorizes deletion process)
 *                                      DEL_NO (application refuses any deletion process)
 *  
 * \return FCT_OK
 *
 * \see sdk30.h
 */
int is_delete(NO_SEGMENT no, void *p1, S_DELETE *param_out)
{
    // Deletion process allowed?
    param_out->deleting=DEL_YES;

    return (FCT_OK);
}

/**
 * Manager reports parameters file received from LLT.
 *  It's activated upon reception of a parameter file by the manager.
 * \param    no (-I) 
 * \param    param_in (I-) 
 *                         - volume_name: SYSTEM (File loaded in CFS)
 *                                        HOST (File loaded in DFS).
 *                         - file_name: Application file name
 * \param    p2 (-I)
 * 
 * \return FCT_OK
 *
 * \see sdk30.h
 */
int file_received(NO_SEGMENT no, S_FILE *param_in, void *p2)
{
    FILE *prt;
    S_FS_PARAM_CREATE ParamCreat;
    int Ret;
    char Dir_File[25];
    char Dir_Label[25];
    int len;
    char rsp[256];
    S_FS_FILE *pFile;

    // Print parameter file received
    prt=fopen("PRINTER","w-");                        // Open printer driver
    pprintf("\x1b""E%s\n""\x1b""F", appName);
    pprintf("File Received :\n/%s/%s\n",param_in->volume_name,param_in->file_name);
    ttestall(PRINTER,0);                              // Print volume+file_name

    memclr(Dir_File,sizeof(Dir_File));
    memclr(Dir_Label,sizeof(Dir_Label));

    sprintf(Dir_Label,"/%s",param_in->volume_name);
    ParamCreat.Mode = FS_WRITEONCE;
    Ret = FS_mount (Dir_Label,&ParamCreat.Mode);
    if (Ret == FS_OK)
    {
        sprintf(Dir_File,"/%s/%s",param_in->volume_name,param_in->file_name);
        pFile = FS_open (Dir_File, "r");             // The file can be open at this stage

        // Eventually read the file and get parameters
        len = FS_length(pFile);                      // File length in bytes
        if(len > sizeof(rsp)) {
          len = sizeof(rsp);
        }
        FS_read(rsp, len, 1, pFile);                 // Read from file

        FS_close(pFile);                             // Close the file
        FS_unmount(Dir_Label);                       // Cannot be deleted as it is located in system disk
    }

    pprintf("%s\n", rsp);

    fclose(prt);                                     // Close printer driver

    return (FCT_OK);
}

/**
 * Inter application messaging.
 *  It's activated each time Manager received a message in its mailbox for this application.
 * \param    no (-I) 
 * \param    param_in (I-) 
 *                         - sender: Sender ID
 *                         - receiver: Receiver ID
 *                         - type: IAM type
 *                         - length: Message length
 *                         - value: Message received
 * \param    p2 (-I)
 * 
 * \return FCT_OK
 *
 * \see sdk30.h
 */
int message_received(NO_SEGMENT no, S_MESSAGE_IAM *param_in, void *p2)
{
    FILE *prt;

    // Print message received from application 2
    prt=fopen("PRINTER","w-");                                           // Open printer driver
    pprintf("\x1b""E%s\n""\x1b""F", appName);
    pprintf ("Message IAM :\n");
    pprintf ("S:%04X R:%04X\n", param_in->sender, param_in->receiver);   // USER2 to TEMPLATE
    pprintf ("IAM Type : %04X \n\n", param_in->type);

    pprintf("%s\n\n\n\n\n\n", param_in->value);                          // Print the message received
    ttestall(PRINTER, 2*100);
    fclose(prt);                                                         // Close printer driver

    return (FCT_OK);
}

/** 
 * It's activated when a card is inserted, swiped or manually entry.
 * Ask the application if the card need a specific processing.
 * \param    no (-I) 
 * \param    param_in (-I) 
 * \param    param_out (-O) 
 *                          - response: REP_OK (card processing)
 *                                      REP_KO (no card processing)  
 *  Only one application wants to process the card, manager calls CARD_INSIDE entry.
 *  More application wants to process the card, manager asks for card removal.
 *  If no application wants to process the card, manager goes on with selection process.
 * 
 * \return FCT_OK
 *
 * \see sdk30.h
 */
int is_card_specific(NO_SEGMENT no, S_TRANSIN *param_in, S_ETATOUT *param_out)
{
    int ret;

    // Return application state
    param_out->returned_state[param_out->response_number].state.response = REP_KO;
    ret = is_name (no, PT_NULL, param_out);

    return (FCT_OK);
}

/** 
 * It's activated when an application has chosen to treat this card has specific.
 * The transaction is done here.
 * \param    no (-I) 
 * \param    param_in (-I) 
 * \param    param_out (-O)
 *                          - rc_payment: PAY_OK (Transaction done)
 *                                        PAY_KO (Transaction rejected)  
 *  If an application returns STOP, polling is stopped and manager asks for card removal.
 *  The application is in charge to ask for amount and currency if needed.
 *
 * \return STOP: Card accepted and transaction process done, polling is stop. 
 *         FCT_OK: Card refused and poll the next application.
 *
 * \see sdk30.h
 */
int card_inside(NO_SEGMENT no, S_TRANSIN *param_in, S_TRANSOUT *param_out)
{
    bool card_accepted = TRUE;

    if (card_accepted)
    {
    // Return transaction status
    param_out->rc_payment = PAY_OK;               // Transaction done, polling is stop
    return (STOP);
    }
    else
    {
        return (FCT_OK);                          // Card refused, poll the next application
    }
}

/** 
 * Ask application to recognize the magnetic, smart or manually card in order to be
 * a candidate.
 * \param    no (-I) 
 * \param    param_in (-I) 
 * \param    param_out (-O) 
 *                          - cardappnumber: 1 = Card accepted
 *                                           0 = Card rejected 
 *                          - cardapp: CARD_PROCESSED (low priority) 
 *                                     CARD_RECOGNIZED (medium priority) 
 *                                     CARD_PRIORITY (high priority)
 *                          - appname: Application name 
 *                          - no: Application number
 *                          - response_number: should be incremented
 *
 * \return FCT_OK
 *
 * \see sdk30.h
 */
int is_for_you_after(NO_SEGMENT no, S_TRANSIN *param_in, S_CARDOUT *param_out)
{

    // case of chip card
    if (param_in->support == CHIP_SUPPORT)
    {
        if(param_in->power_on_result == 0)
        {
            // accept this card
            param_out->returned_state[param_out->response_number].cardappnumber = 1;
            param_out->returned_state[param_out->response_number].cardapp [0].priority = CARD_PROCESSED;
        }
        else
        {
            // reject the card
            param_out->returned_state[param_out->response_number].cardappnumber = 0;
        }
    }

    // case of stripe 2 card
    if (param_in->support == TRACK2_SUPPORT)
    {
        // accept this card
        param_out->returned_state[param_out->response_number].cardappnumber = 1;
        param_out->returned_state[param_out->response_number].cardapp [0].priority = CARD_PRIORITY;
    }

    // case of Card Number Manual entry
    if (param_in->support == OPERATOR_SUPPORT)
    {
        // accept this card
        param_out->returned_state[param_out->response_number].cardappnumber = 1;
        param_out->returned_state[param_out->response_number].cardapp [0].priority = CARD_PRIORITY;
    }

    // give my application name
    strcpy (param_out->returned_state[param_out->response_number].appname, appName) ;
    // give my application number
    param_out->returned_state[param_out->response_number].no_appli = no;
    // give my card name
    strcpy (param_out->returned_state[param_out->response_number].cardapp [0].cardappname, "Template") ;
    // increment the response number
    param_out->response_number++;

    return (FCT_OK);
}

/** 
 * Process a non EMV chip card or a magnetic card or manual entry transaction.
 * \param    no (-I) 
 * \param    param_in (-I)
 * \param    param_out (-O)
 *                          - rc_payment: PAY_OK (Transaction done)
 *                                        PAY_KO (Transaction rejected)
 *  
 * \return FCT_OK
 *
 * \see sdk30.h
 */
int debit_non_emv (NO_SEGMENT no, S_TRANSIN * param_in, S_TRANSOUT * param_out)
{
    FILE *prt;
    int i;

    prt  = fopen("PRINTER", "w-");

    // case of chip card
    if ( param_in->support == CHIP_SUPPORT )
    {
        pprintf("\x1b""E%s\n""\x1b""F", appName);
        if (param_in->historical_bytes.length != 0)
        {
            pprintf("Atr:\n");
            for (i=0; i<param_in->historical_bytes.length; i++)
            {
                pprintf("%02X ", param_in->historical_bytes.historic[i]);
            }
        }
        else
        {
            pprintf("Synchronous card\n");
            pprintf("or Chip mute\n");
        }
        pprintf("\n\n\n\n\n\n");
    }

    // case of stripe 2 card
    if ( param_in->support == TRACK2_SUPPORT )
    {
        pprintf("\x1b""E%s\n""\x1b""F", appName);
        pprintf("Track2:\n%s\n\n\n\n\n\n", param_in->track2);
    }

    // case of Card Number Manual entry
    if ( param_in->support == OPERATOR_SUPPORT )
    {
        pprintf("\x1b""E%s\n""\x1b""F", appName);
        pprintf("Manual Entry:\n%s\n\n\n\n\n\n",param_in->track2);
    }

    ttestall(PRINTER,2*100);
    fclose(prt);

    param_out->noappli      = no;                 // Return application number
    param_out->rc_payment = PAY_OK;               // Transaction done
    return (FCT_OK);
}


/**
 * Services registration and priority.  
 * For all services except idle_message, priority => 0x00 highest and 0xFF lowest
 * For idle_message, priority => 0x00 lowest 0xFF highest
 * \param    AppliNum (-I) 
 * \param    p1 (-I) 
 * \param    p2 (-I)
 * 
 * \return FCT_OK
 *
 * \see sdk30.h
 */
int give_interface(unsigned short AppliNum, void *p1, void *p2)
{
    int i;

    for(i = 0; i < (int)(sizeof(Services) / sizeof(Services[0])); i++)
        Services[i].appli_id = AppliNum;

    ServiceRegister((sizeof(Services) / sizeof(Services[0])), Services);

    return FCT_OK;
}

#ifdef __cplusplus
extern "C" {
#endif

/**
 * entry() is called by the OS for recording services and opening DLL(s).                   
 * The RegisteryPowerFailure() can also be moved to entry().
 *
 * \see sdk30.h
 */
void entry(void)
{
  object_info_t info;
  char * indexExt;

  // Recording services
  ObjectGetInfo(OBJECT_TYPE_APPLI, ApplicationGetCurrent(), &info);
  give_interface(info.application_type, NULL, NULL);

  memcpy(appName, info.name, OBJECT_NAME_LEN);
  memcpy(fileName, info.file_name, OBJECT_FILE_NAME_LEN);
  fileName[OBJECT_FILE_NAME_LEN] = '\0';
  appName[OBJECT_NAME_LEN] = '\0';

  // In the string given to the "is_name" function
  // FAMILY NAME cannot be used because the T_APPNAME type used in is_name function is too short to store FAMILY NAME (T_APPNAME length = 12+1 FAMILY NAME length =15+1)
  // Binary name is used instead. "info.file_name" contains the binary name with the file extension
  // (e.g. ABCDEFG.AGN) and must be removed to be returned in the 'is_name' function.
  indexExt = strstr(fileName, ".");
  if(indexExt != NULL) {
    *indexExt = '\0';
  }
}


#ifdef __cplusplus
}
#endif

