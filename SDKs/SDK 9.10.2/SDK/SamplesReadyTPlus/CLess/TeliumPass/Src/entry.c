/**
 * Entry.c
 * 
 * Application entry point.
 * This file was automatically generated by IngeDev and must be filled out
 * by the developer.
 *                   
 * Purpose:
 *
 * Each time Manager calls an application, it generates only one service
 * call that reaches your application main with the corresponding service
 * number.
 *
 * List of routines in file:
 * - give_your_domain: Return application domain.
 * - after_reset: Application reset processing.
 * - is_name: Report application name to Manager.
 * - is_state: Return application status (initialize or not).
 * - idle_message: Dedicated to display idle message.
 * - more_function: Dedicated to navigation menus.
 * - keyboard_event: Return key pressed.
 * - state: Print terminal content.
 * - consult: Print daily totals.
 * - mcall: Print call schedule.
 * - is_time_function: Need pheripherals at the next call time_function()
 * - time_function: Allow automatic execution of periodic functions.
 * - is_change_init: Conditions for changing manager parameters?
 * - modif_param: Manager reports parameters changing.
 * - is_evol_pg: Conditions for application downloading?
 * - is_delete: Conditions for application deletion?
 * - file_received: Manager reports parameters file received from LLT.
 * - message_received: Inter application messaging.
 * - is_card_specific: Card needs a specific process?
 * - card_inside: Transaction in progress for a specific card.
 * - is_for_you_before: Is chip card as an ISO 7816-3?
 * - is_for_you_after: recognise mag, smc or man card in order to be a candidate.     
 * - give_interface: Services registration and priority.
 * - entry: Call by OS for recording services and opening DLL(s). 
 */

#include "SDK30.H"
#include "TlvTree.h"
#include "oem_cless.h"
#include "GTL_BerTlv.h"
#include "GTL_SharedExchange.h"
#include "ClessInterface.h"

#include "trace.h"
#include "par.h"
#include "par_management.h"
#include "ui_userinterface.h"
#include "fun_demofeatures.h"
#include "err_process.h"
#include "utilities.h"

//+++++++++++++ Macros & preprocessor definitions ++++++++++++++ 

#define __ENTER_KEY     -1
#define __BACK_KEY      -2
#define __EXIT_KEY      -3

#define NUMBER_OF_ITEMS(a) (sizeof(a)/sizeof((a)[0]))

#define SERVICES_LOW_PRIORITY           30
#define SERVICES_HIGH_PRIORITY          10
#define SERVICES_DEFAULT_PRIORITY       20

//++++++++++++++++++++++ Global variables ++++++++++++++++++++++ 

static service_desc_t Services[] = {
    { 0, GIVE_YOUR_DOMAIN, (SAP)Main, (unsigned char)SERVICES_HIGH_PRIORITY },
    { 0, AFTER_RESET, (SAP)Main, (unsigned char)SERVICES_HIGH_PRIORITY },
    { 0, IS_NAME, (SAP)Main, (unsigned char)SERVICES_HIGH_PRIORITY },
    { 0, IS_STATE, (SAP)Main, (unsigned char)SERVICES_HIGH_PRIORITY },
    { 0, IDLE_MESSAGE, (SAP)Main, (unsigned char)SERVICES_DEFAULT_PRIORITY },
    { 0, MORE_FUNCTION, (SAP)Main, (unsigned char)SERVICES_HIGH_PRIORITY },
    { 0, KEYBOARD_EVENT, (SAP)Main, (unsigned char)SERVICES_DEFAULT_PRIORITY },
    { 0, STATE, (SAP)Main, (unsigned char)SERVICES_DEFAULT_PRIORITY },
    { 0, CONSULT, (SAP)Main, (unsigned char)SERVICES_HIGH_PRIORITY },
    { 0, MCALL, (SAP)Main, (unsigned char)SERVICES_HIGH_PRIORITY },
    { 0, IS_TIME_FUNCTION, (SAP)Main, (unsigned char)SERVICES_HIGH_PRIORITY },
    { 0, TIME_FUNCTION, (SAP)Main, (unsigned char)SERVICES_HIGH_PRIORITY },
    { 0, IS_CHANGE_INIT, (SAP)Main, (unsigned char)SERVICES_HIGH_PRIORITY },
    { 0, MODIF_PARAM, (SAP)Main, (unsigned char)SERVICES_HIGH_PRIORITY },
    { 0, IS_EVOL_PG, (SAP)Main, (unsigned char)SERVICES_HIGH_PRIORITY },
    { 0, IS_DELETE, (SAP)Main, (unsigned char)SERVICES_HIGH_PRIORITY },
    { 0, FILE_RECEIVED, (SAP)Main, (unsigned char)SERVICES_HIGH_PRIORITY },
    { 0, MESSAGE_RECEIVED, (SAP)Main, (unsigned char)SERVICES_HIGH_PRIORITY },
    { 0, IS_CARD_EMV_FOR_YOU, (SAP)Main, SERVICES_DEFAULT_PRIORITY },
    { 0, IS_CARD_SPECIFIC, (SAP)Main, (unsigned char)SERVICES_HIGH_PRIORITY },
    { 0, CARD_INSIDE, (SAP)Main, (unsigned char)SERVICES_DEFAULT_PRIORITY },
    { 0, IS_FOR_YOU_AFTER, (SAP)Main, (unsigned char)SERVICES_HIGH_PRIORITY },
    { 0, IS_FOR_YOU_BEFORE, (SAP)Main, SERVICES_DEFAULT_PRIORITY },
    { 0, DEBIT_NON_EMV, (SAP)Main, (unsigned char)SERVICES_HIGH_PRIORITY },
    { 0, IS_CHANGE_INIT, (SAP)Main,  SERVICES_DEFAULT_PRIORITY },
    { 0, IS_LICENCED, (SAP)Main, SERVICES_DEFAULT_PRIORITY },
    { 0, CLESS_GIVE_INFO, (SAP)Main, SERVICES_DEFAULT_PRIORITY },
    { 0, CLESS_IS_FOR_YOU, (SAP)Main, SERVICES_DEFAULT_PRIORITY },
    { 0, CLESS_DEBIT, (SAP)Main, SERVICES_DEFAULT_PRIORITY },
    { 0, CLESS_DEBIT_AID, (SAP)Main, SERVICES_DEFAULT_PRIORITY },
    { 0, CLESS_END, (SAP)Main, SERVICES_DEFAULT_PRIORITY }
};

typedef struct Params
{
    char Old_Date[24+1];
    char Old_FmtDate[24+1];
    char Old_Language[24+1];
    char Old_Pabx[24+1];
    char Old_PPad[24+1];
    char Old_PPadType[24+1];
    char Old_ISOreader[24+1];
    char Old_TMSaccess[24+1];
} S_PARAMS;

static char appName[OBJECT_NAME_LEN + 1];
static char fileName[OBJECT_FILE_NAME_LEN + 1];
static const char coldReset[] = "Cold Reset\nFrom ";
static const char warmReset[] = "Warm Reset\nFrom ";
static const char timeToCall[] = "Time to call\nFrom ";
static const char idleMsg[] = "\nSample\nApplication";
static const char szDate[] = "Date:%.2s/%.2s/%.2s  %.2s:%.2s\n";
static TRC_Trace_t trc_cless;

/**
 * Ask application to define its working environment, Manager will select 
 *  common parameters set and adapt its internal processing.
 * \param    no (-I)
 * \param    p1 (-I)
 * \param    param_out (-O) 
 *                          - application_type: TYP_CARTE (French Bank)
 *                                              TYP_HEALTH(French Health)
 *                                              TYP_EXPORT (Export)
 *                          - mask:  Key "F" 031 -> Parameters initialization (0:absent, 1:present)
 *                          - response_number: should be incremented
 *
 * \return FCT_OK
 *
 * \see sdk30.h
 */
int give_your_domain(NO_SEGMENT no, void *p1, S_INITPARAMOUT *param_out)
{

    // Return application domain to Manager
    // Setting parameters initialization
    param_out->returned_state[param_out->response_number].mask = MSK_ALL_PARAM;
    // International domain
    param_out->returned_state[param_out->response_number].application_type = TYP_EXPORT;
    param_out->response_number++;

    return (FCT_OK);
}

/**
 * Initialize data and create disks, eventually ends interrupted transaction
 *  by returning S_TRANS_OUT.
 * \param    no (-I) 
 * \param    p1 (-I)
 * \param    param_out (-O) Eventually ends interrupted transaction
 *
 * \return FCT_OK
 *
 * \see sdk30.h
 */
int after_reset(NO_SEGMENT no, void *p1, S_TRANSOUT *param_out)
{
    int ret;
    FILE *hDisplay;
    unsigned char chgt;
    TYPE_CHGT  type;
    char tmp[64];

    // Reset management
    hDisplay  = fopen( "DISPLAY",  "w" );  // Open display driver

    first_init(no, &chgt, (unsigned char *)&type);          // New software loaded ?
    if (chgt==0xFF)                        // Yes, just loaded with first execution
    {
        sprintf(tmp, "%s%s", coldReset, appName);
        raz_init(no);                      // Reset downloading indicator
        
    }
    else                                   // No, already loaded and executed
    {
        sprintf(tmp, "%s%s", warmReset, appName);
    }

    TRC_Init(); //enable traces

    guiScreen(appName, tmp, GL_ICON_NONE, UI_TIMEOUT_3_SECONDS);
    fclose( hDisplay  );                   // Close display driver

    //TPasslib_open();
    ret = TPass_IsConnected();
    if (ret == ERR_TPASS_OK)
    {
        TPass_BacklightLevel(0);
        TPass_FirstLine();
        TPass_Display("\n\nTeliumPass Test");
        return FCT_OK;
    }
    else
    {
        guiScreen(appName, "CHECK TeliumPass\nPRESENCE ", GL_ICON_NONE, UI_TIMEOUT_3_SECONDS);
        return STOP;
    }
}

/**
 * Report application name to Manager.
 * \param    no (-I) 
 * \param    p1 (-I) 
 * \param    param_out (-O) 
 *                          - appname: Application name 
 *                          - no: Application number
 *                          - response_number: should be incremented
 *
 * \return FCT_OK
 *
 * \see sdk30.h
 */
int is_name(NO_SEGMENT no, void *p1, S_ETATOUT *param_out)
{
    // Report application name to Manager cannot return the family name
    // because the T_APPNAME type used in the "is_name" function is too short to store
    // the FAMILY NAME (T_APPNAME length = 12+1 FAMILY NAME length =15+1)
    // we use the binary name instead (without extension, and whose length is 11+1)

    memset(param_out->returned_state[param_out->response_number].appname,0, sizeof(param_out->returned_state[param_out->response_number].appname));
    strncpy(param_out->returned_state[param_out->response_number].appname, fileName, sizeof(param_out->returned_state[param_out->response_number].appname) - 1);
    param_out->returned_state[param_out->response_number].no_appli = no;
    param_out->returned_state[param_out->response_number].state.response = REP_OK;
    param_out->response_number++;

    return (FCT_OK);
}

/**
 * Report application state initialize or not to Manager.
 * \param    no (-I) 
 * \param    p1 (-I) 
 * \param    param_out (-O) 
 *                          - response: REP_OK (Initialized)
 *                                      REP_KO (Not initialized) 
 * 
 * \return FCT_OK
 *
 * \see sdk30.h
 */
int is_state(NO_SEGMENT no, void *p1, S_ETATOUT *param_out)
{
    int retour;

    // Return application state
    param_out->returned_state[param_out->response_number].state.response = REP_OK;
    retour = is_name (no, PT_NULL, param_out);

    return (retour);
}

/**
 * Allows the application to display its idle message when Manager goes back 
 *  to idle (the application should have the higher priority).
 * \param    no (-I) 
 * \param    p1 (-I) 
 * \param    p2 (-I) 
 *
 * \return FCT_OK
 *
 * \see sdk30.h
 */
int idle_message (NO_SEGMENT no, void *p1, void *p2)
{
    FILE *hDisplay;

    // Idle message management
    hDisplay = fopen("DISPLAY","w");        // Open display driver.

    guiScreen(appName, (char *)idleMsg, GL_ICON_NONE, UI_TIMEOUT_100_MILLISECONDS);

    fclose(hDisplay);                       // Close display driver
    return FCT_OK;
}

/**
 * It's activated when pressing on "F" key to select the right application 
 *  to go on menu.
 * \param    no (-I) 
 * \param    p1 (-I) 
 * \param    p2 (-I) 
 *
 * \return FCT_OK
 *
 * \see sdk30.h
 * 
 * \note Other prototype variant 'int more_function_ext(NO_SEGMENT no, S_ETATOUT *in, void *out)'
 *       can be used with INCENDO.
 *       This other prototype is used if the application manages more than one application name.
 *       The 'S_ETATOUT' structure allows to know the name selected by the user after pressing the "F" key.
 *       This new prototype can be used with SDK version >= 6.5.
 */
int more_function( NO_SEGMENT no, void *p1, void *p2 )
{
    UI_MenuMainDisplay();
    return FCT_OK;
}

/**
 * It's activated when key is pressed and terminal is in idle mode.
 * \param    noappli 
 * \param    key_in (I-)
 *                       - keycode: Key pressed. 
 * \param    key_out (-O)
 *                       - keycode: Key pressed, new key, 0=disable.
 * 
 * \return FCT_OK
 *
 * \see sdk30.h
 */
int keyboard_event(NO_SEGMENT noappli,S_KEY *key_in,S_KEY *key_out)
{
    // Keyboard management
    switch (key_in->keycode)
    {
    case N0: case N1: case N2: case N3: case N4:
    case N5: case N6: case N7: case N8: case N9:
    case T_VAL : case T_POINT :
        key_out->keycode = 0;               // Inhibit these keys to Manager for International domain
        break;
    case F1 : case F2 : case F3 : case F4 :
    case T_CORR : case T_ANN : case NAVI_CLEAR : case NAVI_OK :
    case UP : case DOWN :
    case T_F :                              // do not filter F key and return the same key !
        key_out->keycode=key_in->keycode;   // Return the same key value for keys above !
        break;
    default :
        key_out->keycode=key_in->keycode;
        break;
    }

    return (FCT_OK);
}

/**
 * It's activated on "F" key: Consultation->State. 
 *  To print terminal content.  
 * \param    no (-I) 
 * \param    p1 (-I) 
 * \param    p2 (-I) 
 *
 * \return FCT_OK
 *
 * \see sdk30.h
 */
int state (NO_SEGMENT no, void *p1, void *p2)
{
    DATE date;
    object_info_t infos;
    FILE     *hPrinter;

    // Print application info
    ObjectGetInfo(OBJECT_TYPE_APPLI, no, &infos);       // Retrieve application info

    hPrinter=fopen( "PRINTER", "w-*" );                 // Open printer driver
    if (hPrinter!=NULL)
    {
        pprintf("\x1b""E%s\n""\x1b""F",appName);        // Print application name
        pprintf("         STATE         \n"
                "Application used as\n"
                "IngeDev Template\n\n");
        read_date(&date);                               // Print date and time
        pprintf(szDate, date.day, date.month, date.year, date.hour, date.minute);
        pprintf("File    : %s\n",infos.file_name);      // Print application file name
        pprintf("CRC     : %04x\n",infos.crc);          // Print application CRC
        ttestall(PRINTER, 0);

        fclose(hPrinter);                               // Close printer driver
    }

    return FCT_OK;
}

/**
 * It's activated on "F" key: Consultation->Transactions. 
 *  To print transactions total receipt. 
 * \param    no (-I) 
 * \param    p1 (-I) 
 * \param    p2 (-I) 
 *
 * \return FCT_OK
 *
 * \see sdk30.h
 */
int consult (NO_SEGMENT no, void *p1, void *p2)
{
    DATE date;
    FILE *hPrinter;

    // Print daily totals
    hPrinter=fopen("PRINTER", "w-*");                    // Open printer driver
    if (hPrinter!=NULL)
    {
        pprintf("\x1b""E%s\n""\x1b""F", appName);        // Print application name
        pprintf("        CONSULT        \n"
                "Print daily totals here\n"
                "Number of Debit/Credit \n"
                "Totals of Debit/Credit \n"
                "Number of Cancel\n\n");
        read_date(&date);                                // Print date and time
        pprintf(szDate, date.day, date.month, date.year, date.hour, date.minute);

        ttestall(PRINTER, 3*100);
        fclose(hPrinter);                                // Close printer driver
    }

    return FCT_OK;
}

/**
 * It's activated on "F" key: Consultation->Call->Planning of Call. 
 *  To print call schedule receipt. 
 * \param    no (-I) 
 * \param    p1 (-I) 
 * \param    p2 (-I) 
 *
 * \return FCT_OK
 *
 * \see sdk30.h
 */
int mcall (NO_SEGMENT no, void *p1, void *p2)
{
    DATE date;
    FILE *hPrinter;

    // Print call schedule
    hPrinter=fopen("PRINTER", "w-*");                     // Open printer driver
    if (hPrinter!=NULL)
    {
        pprintf("\x1b""E%s\n""\x1b""F", appName);         // Print application name
        pprintf("         MCALL         \n"
                "Planning of call here  \n"
                "Time release batch     \n"
                "Time loading parameters\n"
                "Time loading hotlist\n\n");
        read_date(&date);                                 // Print date and time
        pprintf(szDate, date.day, date.month, date.year, date.hour, date.minute);

        ttestall(PRINTER, 3*100);
        fclose(hPrinter);                                 // Close printer driver
    }

    return FCT_OK;
}

/**
 * Do you need the peripherals at the next call of time_function()?.
 *  It's call every minute.
 * \param    no (-I) 
 * \param    p1 (-I) 
 * \param    param_out (-O) 
 *                          - response: REP_OK (Manager closes all peripherals)
 *                                      REP_KO (Manager keeps all peripherals opened) 
 * 
 * \return FCT_OK
 *
 * \see sdk30.h
 */
int is_time_function(NO_SEGMENT no, void *p1, S_ETATOUT *param_out)
{
    int retour;

    // Peripherals needed?
    param_out->returned_state[param_out->response_number].state.response=REP_OK;
    retour = is_name (no, PT_NULL, param_out);

    return(FCT_OK);
}

/**
 * Allow application to execute its own periodical process. 
 *  It's call every minute. 
 * \param    no (-I)
 * \param    p1 (-I) 
 * \param    p2 (-I) 
 *
 * \return FCT_OK
 *
 * \see sdk30.h
 */
int time_function(NO_SEGMENT no, void *p1, void *p2)
{
    char tmp[64];

    // Periodical function in progress
    fopen("DISPLAY","w");                 // Open display driver

    sprintf(tmp, "%s%s", timeToCall, appName);
    guiScreen(appName, tmp, GL_ICON_NONE, UI_TIMEOUT_3_SECONDS);
    fclose(stdout());                     // Close display driver

    return (FCT_OK);
}

/**
 * It's activated on "F" key: Initialization->Parameters->List.
 *  Each time Manager wants to change its own parameters.
 * \param    no (-I) 
 * \param    p1 (-I) 
 * \param    param_out (-O)
 *                          - mask: Key "F" 031 -> Parameters modification (0:accepting, 1:refusing)
 *
 * \return FCT_OK
 *
 * \see sdk30.h
 */
int is_change_init(NO_SEGMENT no, void *p1, S_ETATOUT *param_out)
{
    S_ETATOUT etatout;
    int       retour;
    memcpy(&etatout, param_out, sizeof(etatout));

    // accept all
    etatout.returned_state[etatout.response_number].state.mask=0;
    memcpy(param_out,&etatout,sizeof(etatout));
    retour = is_name (no, PT_NULL, param_out);
    return(FCT_OK);
}

/**
 * It's activated on "F" key: Initialization->Parameters->List.
 *  Each time Manager changed its own parameters.
 * \param    noappli (I-)
 * \param    param_in (I-)
 *                         - mask: Key "F" 031 -> Parameters modification (0:not modified, 1:modified)
 * \param    p2 (-I) 
 *
 * \return FCT_OK
 *
 * \see sdk30.h
 */
int modif_param(NO_SEGMENT noappli, S_MODIF_P *param_in, void *p2)
{
    char tmp[64];
    S_MODIF_P param_changed;

    memcpy(&param_changed, param_in,sizeof(param_changed));
    fopen("DISPLAY","w");

    sprintf(tmp, "MODIF_PARAM\n%04x",(int)param_changed.etatout.returned_state[0].state.mask);
    guiScreen(appName, tmp, GL_ICON_NONE, UI_TIMEOUT_3_SECONDS);
    fclose(stdout());
    return(FCT_OK);
}

/**
 * It's activated each time Manager wants to run a downloading session (local or remote).
 *  "F" key: Evolution->Load->Local or Evolution->Remote Load
 * \param    no (-I) 
 * \param    p1 (-I) 
 * \param    param_out (-O) 
 *                          - response: REP_OK (application authorizes donwloading process)
 *                                      REP_KO (application refuses any downloading process)
 *  
 * \return FCT_OK
 *
 * \see sdk30.h
 */
int is_evol_pg(NO_SEGMENT no, void *p1, S_ETATOUT *param_out)
{
    int retour;

    // Downloading process allowed?
    param_out->returned_state[param_out->response_number].state.response=REP_OK;
    retour = is_name (no, PT_NULL, param_out);

    return(FCT_OK);
}

/**
 * It's activated each time Manager wants to delete an application.
 *  "F" key: Deletion
 * \param    no (-I) 
 * \param    p1 (-I) 
 * \param    param_out (-O)
 *                          - response: DEL_YES (application authorizes deletion process)
 *                                      DEL_NO (application refuses any deletion process)
 *  
 * \return FCT_OK
 *
 * \see sdk30.h
 */
int is_delete(NO_SEGMENT no, void *p1, S_DELETE *param_out)
{
    // Deletion process allowed?
    param_out->deleting=DEL_YES;

    return (FCT_OK);
}

/**
 * Manager reports parameters file received from LLT.
 *  It's activated upon reception of a parameter file by the manager.
 * \param    no (-I) 
 * \param    param_in (I-) 
 *                         - volume_name: SYSTEM (File loaded in CFS)
 *                                        HOST (File loaded in DFS).
 *                         - file_name: Application file name
 * \param    p2 (-I)
 * 
 * \return FCT_OK
 *
 * \see sdk30.h
 */
int file_received(NO_SEGMENT no, S_FILE *param_in, void *p2)
{
    FILE *prt;

    // Print parameter file received
    prt=fopen("PRINTER","w-");                        // Open printer driver
    pprintf("\x1b""E%s\n""\x1b""F", appName);
    pprintf("File Received :\n/%s/%s\n",param_in->volume_name,param_in->file_name);
    ttestall(PRINTER,0);                              // Print volume+file_name

    if (strcmp(param_in->file_name, "TPASS.PAR")==0)
    {
        PAR_Import("/HOST/TPASS.PAR");
    }

    fclose(prt);                                     // Close printer driver

    return (FCT_OK);
}

/**
 * Inter application messaging.
 *  It's activated each time Manager received a message in its mailbox for this application.
 * \param    no (-I) 
 * \param    param_in (I-) 
 *                         - sender: Sender ID
 *                         - receiver: Receiver ID
 *                         - type: IAM type
 *                         - length: Message length
 *                         - value: Message received
 * \param    p2 (-I)
 * 
 * \return FCT_OK
 *
 * \see sdk30.h
 */
int message_received(NO_SEGMENT no, S_MESSAGE_IAM *param_in, void *p2)
{
    FILE *prt;

    // Print message received from application 2
    prt=fopen("PRINTER","w-");                                           // Open printer driver
    pprintf("\x1b""E%s\n""\x1b""F", appName);
    pprintf ("Message IAM :\n");
    pprintf ("S:%04X R:%04X\n", param_in->sender, param_in->receiver);   // USER2 to TEMPLATE
    pprintf ("IAM Type : %04X \n\n", param_in->type);

    pprintf("%s\n\n\n\n\n\n", param_in->value);                          // Print the message received
    ttestall(PRINTER, 2*100);
    fclose(prt);                                                         // Close printer driver

    return (FCT_OK);
}

/** 
 * It's activated when a card is inserted, swiped or manually entry.
 * Ask the application if the card need a specific processing.
 * \param    no (-I) 
 * \param    param_in (-I) 
 * \param    param_out (-O) 
 *                          - response: REP_OK (card processing)
 *                                      REP_KO (no card processing)  
 *  Only one application wants to process the card, manager calls CARD_INSIDE entry.
 *  More application wants to process the card, manager asks for card removal.
 *  If no application wants to process the card, manager goes on with selection process.
 * 
 * \return FCT_OK
 *
 * \see sdk30.h
 */
int is_card_specific(NO_SEGMENT no, S_TRANSIN *param_in, S_ETATOUT *param_out)
{
    int ret;

    // Return application state
    param_out->returned_state[param_out->response_number].state.response = REP_KO;
    ret = is_name (no, PT_NULL, param_out);

    return (FCT_OK);
}

/** 
 * It's activated when an application has chosen to treat this card has specific.
 * The transaction is done here.
 * \param    no (-I) 
 * \param    param_in (-I) 
 * \param    param_out (-O)
 *                          - rc_payment: PAY_OK (Transaction done)
 *                                        PAY_KO (Transaction rejected)  
 *  If an application returns STOP, polling is stopped and manager asks for card removal.
 *  The application is in charge to ask for amount and currency if needed.
 *
 * \return STOP: Card accepted and transaction process done, polling is stop. 
 *         FCT_OK: Card refused and poll the next application.
 *
 * \see sdk30.h
 */
int card_inside(NO_SEGMENT no, S_TRANSIN *param_in, S_TRANSOUT *param_out)
{
    bool card_accepted = TRUE;

    if (card_accepted)
    {
    // Return transaction status
    param_out->rc_payment = PAY_OK;               // Transaction done, polling is stop
    return (STOP);
    }
    else
    {
        return (FCT_OK);                          // Card refused, poll the next application
    }
}

/** 
 * Ask application to recognize the magnetic, smart or manually card in order to be
 * a candidate.
 * \param    no (-I) 
 * \param    param_in (-I) 
 * \param    param_out (-O) 
 *                          - cardappnumber: 1 = Card accepted
 *                                           0 = Card rejected 
 *                          - cardapp: CARD_PROCESSED (low priority) 
 *                                     CARD_RECOGNIZED (medium priority) 
 *                                     CARD_PRIORITY (high priority)
 *                          - appname: Application name 
 *                          - no: Application number
 *                          - response_number: should be incremented
 *
 * \return FCT_OK
 *
 * \see sdk30.h
 */
int is_for_you_after(NO_SEGMENT no, S_TRANSIN *param_in, S_CARDOUT *param_out)
{

    // case of chip card
    if (param_in->support == CHIP_SUPPORT)
    {
        if(param_in->power_on_result == 0)
        {
            // accept this card
            param_out->returned_state[param_out->response_number].cardappnumber = 1;
            param_out->returned_state[param_out->response_number].cardapp [0].priority = CARD_PROCESSED;
        }
        else
        {
            // reject the card
            param_out->returned_state[param_out->response_number].cardappnumber = 0;
        }
    }

    // case of stripe 2 card
    if (param_in->support == TRACK2_SUPPORT)
    {
        // accept this card
        param_out->returned_state[param_out->response_number].cardappnumber = 1;
        param_out->returned_state[param_out->response_number].cardapp [0].priority = CARD_PRIORITY;
    }

    // case of Card Number Manual entry
    if (param_in->support == OPERATOR_SUPPORT)
    {
        // accept this card
        param_out->returned_state[param_out->response_number].cardappnumber = 1;
        param_out->returned_state[param_out->response_number].cardapp [0].priority = CARD_PRIORITY;
    }

    // give my application name
    strcpy (param_out->returned_state[param_out->response_number].appname, appName) ;
    // give my application number
    param_out->returned_state[param_out->response_number].no_appli = no;
    // give my card name
    strcpy (param_out->returned_state[param_out->response_number].cardapp [0].cardappname, "Template") ;
    // increment the response number
    param_out->response_number++;

    return (FCT_OK);
}

/** 
 * Process a non EMV chip card or a magnetic card or manual entry transaction.
 * \param    no (-I) 
 * \param    param_in (-I)
 * \param    param_out (-O)
 *                          - rc_payment: PAY_OK (Transaction done)
 *                                        PAY_KO (Transaction rejected)
 *  
 * \return FCT_OK
 *
 * \see sdk30.h
 */
int debit_non_emv (NO_SEGMENT no, S_TRANSIN * param_in, S_TRANSOUT * param_out)
{
    FILE *prt;
    int i;

    prt  = fopen("PRINTER", "w-");

    // case of chip card
    if ( param_in->support == CHIP_SUPPORT )
    {
        pprintf("\x1b""E%s\n""\x1b""F", appName);
        if (param_in->historical_bytes.length != 0)
        {
            pprintf("Atr:\n");
            for (i=0; i<param_in->historical_bytes.length; i++)
            {
                pprintf("%02X ", param_in->historical_bytes.historic[i]);
            }
        }
        else
        {
            pprintf("Synchronous card\n");
            pprintf("or Chip mute\n");
        }
        pprintf("\n\n\n\n\n\n");
    }

    // case of stripe 2 card
    if ( param_in->support == TRACK2_SUPPORT )
    {
        pprintf("\x1b""E%s\n""\x1b""F", appName);
        pprintf("Track2:\n%s\n\n\n\n\n\n", param_in->track2);
    }

    // case of Card Number Manual entry
    if ( param_in->support == OPERATOR_SUPPORT )
    {
        pprintf("\x1b""E%s\n""\x1b""F", appName);
        pprintf("Manual Entry:\n%s\n\n\n\n\n\n",param_in->track2);
    }

    ttestall(PRINTER,2*100);
    fclose(prt);

    param_out->noappli      = no;                 // Return application number
    param_out->rc_payment = PAY_OK;               // Transaction done
    return (FCT_OK);
}

/**
 * Services registration and priority.  
 * For all services except idle_message, priority => 0x00 highest and 0xFF lowest
 * For idle_message, priority => 0x00 lowest 0xFF highest
 * \param    AppliNum (-I) 
 * \param    p1 (-I) 
 * \param    p2 (-I)
 * 
 * \return FCT_OK
 *
 * \see sdk30.h
 */
int give_interface(unsigned short no,void *p1,void *p2)
{
    int i;

    for(i = 0; i < (int)(sizeof(Services) / sizeof(Services[0])); i++)
        Services[i].appli_id = no;
    ServiceRegister((sizeof(Services) / sizeof(Services[0])), Services);
    return (FCT_OK);
}

int is_card_emv_for_you(NO_SEGMENT no, S_AID *in, S_CARDOUT *out)
{
    (void)in;

    // Initialise the output parameter
    memset(&out->returned_state[out->response_number], 0, sizeof(out->returned_state[out->response_number]));
    strncpy(out->returned_state[out->response_number].appname, appName, sizeof(out->returned_state[out->response_number].appname) - 1);
    out->returned_state[out->response_number].no_appli = no;
    out->returned_state[out->response_number].cardappnumber = 0;
    out->response_number++;
    
    return FCT_OK;
}

int is_for_you_before(NO_SEGMENT no, S_TRANSIN *in, S_ETATOUT *out)
{
    (void)in;

    // Initialise the output parameter
    memset(&out->returned_state[out->response_number], 0, sizeof(out->returned_state[out->response_number]));
    strncpy(out->returned_state[out->response_number].appname, appName, sizeof(out->returned_state[out->response_number].appname) - 1);
    out->returned_state[out->response_number].no_appli = no;
    out->returned_state[out->response_number].state.response = 0;
    out->response_number++;
    
    return FCT_OK;
}

int is_licenced(NO_SEGMENT no, void *in, S_ETATOUT *out)
{
    // Initialise the output parameter
    memset(&out->returned_state[out->response_number], 0, sizeof(out->returned_state[out->response_number]));
    strncpy(out->returned_state[out->response_number].appname, appName,  sizeof(out->returned_state[out->response_number].appname) - 1);
    out->returned_state[out->response_number].no_appli = no;
    out->returned_state[out->response_number].state.response = REP_KO;
    out->response_number++;

    return FCT_OK;
}

int cless_give_info(NO_SEGMENT no, S_TRANSIN * pParamIn, S_CLESS_GIVEINFO* pParamOut)
{
    TRC_Trace_t trc_entry;
    TLV_TREE_NODE hOutputTlvTree;
    int nResult;

    trc_entry = TRC_HandleGet();

    TRC_Trace(trc_entry, TRC_LEVEL_INFO, __FILE__, __LINE__, "Transaction amount = %02lx", pParamIn->amount);
    TRC_Trace(trc_entry, TRC_LEVEL_INFO, __FILE__, __LINE__, "Currency Code = %c%c%c", pParamIn->currency.code[0], pParamIn->currency.code[1], pParamIn->currency.code[2]);
    TRC_Trace(trc_entry, TRC_LEVEL_INFO, __FILE__, __LINE__, "Currency Label = %c%c%c", pParamIn->currency.nom[0], pParamIn->currency.nom[1], pParamIn->currency.nom[2]);

    memset (pParamOut, 0, sizeof(*pParamOut));
    
    // Create the TLV Tree
    hOutputTlvTree = TlvTree_New(0);

    // Fill the hOutputTlvTree with the correct parameters (depending on the choosen configuration identifier)
    PAR_GetClessParameters(hOutputTlvTree);
    
    if (hOutputTlvTree != NULL)
    {
        // Serialize the TLV Tree in the DEL * of pParamOut
        nResult = TlvTree_Serialize(hOutputTlvTree, TLV_TREE_SERIALIZER_DEFAULT, (unsigned char *)(&(pParamOut->del)), sizeof (_DEL_));
        
        if (nResult < 0)
        {
            memset (&(pParamOut->del), 0, sizeof (_DEL_));
        }
        
        // Release the TLV Tree
        TlvTree_Release(hOutputTlvTree);
    }

    return (FCT_OK);
}

static void cless_dump_data (T_SHARED_DATA_STRUCT * data, const int indent)
{
    int idx, loc;
    int pos;
    int res;
    int flag;
    unsigned long tag;
    unsigned long len;
    unsigned char * val;
    char buf[512];
    char stm[32];
    T_SHARED_DATA_STRUCT tmp;

    pos = SHARED_EXCHANGE_POSITION_NULL;
    res = STATUS_SHARED_EXCHANGE_OK;
    while (res == STATUS_SHARED_EXCHANGE_OK)
    {
        res = GTL_SharedExchange_GetNext(data, &pos, &tag, &len, (const unsigned char **)&val);

        if (res == STATUS_SHARED_EXCHANGE_OK)
        {
            memset(buf, 0, sizeof(buf));
            for (idx=0;idx<indent;idx++)
            {
                strcat(buf, "  ");
            }

            memset(stm, 0, sizeof(stm));
            sprintf(stm, "T:%08lx L:%04lx ", tag, len);
            strcat(buf, stm);

            if (GTL_BerTlv_IsTagConstructedObject(tag))
            {
                TRC_Trace(trc_cless, TRC_LEVEL_INFO, __FILE__, __LINE__, buf);
                GTL_SharedExchange_InitEx(&tmp, len, len, val);
                cless_dump_data (&tmp, indent+1);
            }
            else
            {
                strcat(buf, "V:");
                idx = 0;
                flag = FALSE;
                while (idx < (unsigned int)len)
                {
                    loc = 0;
                    while ((idx+loc < (unsigned int)len) && (loc < (14 - indent + ((10 + indent)  * (flag != FALSE)))))
                    {
                        memset(stm, 0, sizeof(stm));
                        sprintf(stm, "%02x", val[idx+loc]);
                        strcat(buf, stm);
                        loc++;
                    }
                    idx += loc;
                    TRC_Trace(trc_cless, TRC_LEVEL_INFO, __FILE__, __LINE__, buf);
                    flag = TRUE;
                }
            }
        }
    }
}

int cless_debit_aid(NO_SEGMENT no, unsigned int nSize, void * pData)
{
    T_SERVICE_CALL_SHARED_EXCHANGE_STRUCT * pSharedStruct;

    (void)no;
    (void)nSize;

    trc_cless = TRC_HandleGet();

    pSharedStruct = (T_SERVICE_CALL_SHARED_EXCHANGE_STRUCT *)pData;

    if (nSize != sizeof (T_SERVICE_CALL_SHARED_EXCHANGE_STRUCT))
    {
        TRC_Trace(trc_cless, TRC_LEVEL_ERR, __FILE__, __LINE__, "Error : nSize not a shared structure");
        TRC_Trace(trc_cless, TRC_LEVEL_ERR, __FILE__, __LINE__, "(nSize = %02x", nSize);
        return CLESS_CR_MANAGER_END;
    }

    cless_dump_data(pSharedStruct->pDataStruct, 0);

    return (CLESS_CR_MANAGER_END);
}

int cless_end(NO_SEGMENT no)
{
    return FCT_OK;
}

int cless_is_for_you(NO_SEGMENT no, unsigned int nSize, void * pData)
{
    T_SERVICE_CALL_SHARED_EXCHANGE_STRUCT * pSharedStruct;
    unsigned char ucPriority;

    (void)no;
    (void)nSize;

    trc_cless = TRC_HandleGet();

    pSharedStruct = (T_SERVICE_CALL_SHARED_EXCHANGE_STRUCT *)pData;
    if (nSize != sizeof (T_SERVICE_CALL_SHARED_EXCHANGE_STRUCT))
    {
        TRC_Trace(trc_cless, TRC_LEVEL_ERR, __FILE__, __LINE__, "Error : nSize not a shared structure");
        TRC_Trace(trc_cless, TRC_LEVEL_ERR, __FILE__, __LINE__, "(nSize = %02x", nSize);
        return FCT_OK;
    }

    cless_dump_data(pSharedStruct->pDataStruct, 0);


    // Clear the buffer
    GTL_SharedExchange_ClearEx (pSharedStruct->pDataStruct, FALSE);

    /*  The TAG_GENERIC_PRIORITY tag is mandatory for new architecture if
    the application wants to manage the card on CLESS_DEBIT. If the tag
    is not provided, the application will not be called on CLESS_DEBIT,
    even if it returns STOP. */
    // Set the interest level (=priority)
    ucPriority = 30;
    GTL_SharedExchange_AddTag (pSharedStruct->pDataStruct, TAG_GENERIC_PRIORITY, 1, &ucPriority);
    return FCT_OK;
}

int cless_debit(NO_SEGMENT no, unsigned int nSize, void * pData)
{
    T_SERVICE_CALL_SHARED_EXCHANGE_STRUCT * pSharedStruct;

    (void)no;
    (void)nSize;

    trc_cless = TRC_HandleGet();

    pSharedStruct = (T_SERVICE_CALL_SHARED_EXCHANGE_STRUCT *)pData;
    if (nSize != sizeof (T_SERVICE_CALL_SHARED_EXCHANGE_STRUCT))
    {
        TRC_Trace(trc_cless, TRC_LEVEL_ERR, __FILE__, __LINE__, "Error : nSize not a shared structure");
        TRC_Trace(trc_cless, TRC_LEVEL_ERR, __FILE__, __LINE__, "(nSize = %02x", nSize);
        return CLESS_CR_MANAGER_END;
    }

    cless_dump_data(pSharedStruct->pDataStruct, 0);

    return (CLESS_CR_MANAGER_END);
}

/**
 * entry() is called by the OS for recording services and opening DLL(s).                   
 * The RegisteryPowerFailure() can also be moved to entry().
 *
 * \see sdk30.h
 */
void entry(void)
{
  object_info_t info;
  char * indexExt;

  // Recording services
  ObjectGetInfo(OBJECT_TYPE_APPLI, ApplicationGetCurrent(), &info);
  give_interface(info.application_type, NULL, NULL);

  memcpy(appName, info.name, OBJECT_NAME_LEN);
  memcpy(fileName, info.file_name, OBJECT_FILE_NAME_LEN);
  fileName[OBJECT_FILE_NAME_LEN] = '\0';
  appName[OBJECT_NAME_LEN] = '\0';

  // In the string given to the "is_name" function
  // FAMILY NAME cannot be used because the T_APPNAME type used in is_name function is too short to store FAMILY NAME (T_APPNAME length = 12+1 FAMILY NAME length =15+1)
  // Binary name is used instead. "info.file_name" contains the binary name with the file extension
  // (e.g. ABCDEFG.AGN) and must be removed to be returned in the 'is_name' function.
  indexExt = strstr(fileName, ".");
  if(indexExt != NULL) {
    *indexExt = '\0';
  }
}

