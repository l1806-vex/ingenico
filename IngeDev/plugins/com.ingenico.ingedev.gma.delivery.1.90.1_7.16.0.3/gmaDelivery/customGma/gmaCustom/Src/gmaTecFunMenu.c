

/**
 * 
 *	@file gmaTecFunMenu.c
 *
 *
 * This file contains the functions wich will be used to compose and
 * display the technical menu or plugin menu.
 * 
 *
 */


#include "string.h"
#include "stdlib.h"
#include "stdio.h"
#include "ctype.h"

#include "unicapt.h"

#include "appList.h"
#include "appInit.h"
#include "gmaMsg.h"
#include "gmaAppMsg.h"
#include "gmaMedia.h"
#include "gmaDefines.h"
#include "gmaCustomSemaphores.h"
#include "gmaCustomDefines.h"
#include "gmaHmiCustom.h"
#include "gmaGenCustom.h"
#include "menuLib.h"
#include "gmaMsgSup.h"
#include "editlib.h"
#include "resources.h"
#include "gmaCustomUtil.h"
//#define DEBUG_ON
#include "debuglib.h"

/**
 * Table of the menu items added by the plugins.
 */
sPlugInMenuItem_t plugInMenu[GMA_MAX_PG_MENU_ITEMS];

/**
 * Table of the plugin that have added menu items to the 
 * technical menu.
 */
sPlugInMenuList_t plugInList[GMA_MAX_PG_MENU_ITEMS];

/**
 * Table of the edit string resources added by the plugins
 */
sPlugInEditResource_t plugInEditResList[GMA_MAX_PG_EDIT_RES_ITENS];

/**
 * Number of menu items in the \ref plugInMenu table
 */
uint8 numPlugInMenuItems = 0;

/**
 * Number of plugins in the \ref plugInList table.
 */
uint8 numPlugInItemsList = 0;

/**
 * Number of edit string resource items in the \ref plugInEditResList table
 */
uint8 numPlugInEditRes   = 0;

static int16 gmaTecFunNotifyPG(uint16 appID, uint8 logApp, uint8 itemId);
static int16 gmaTecFunDisplayPGItemsMenu (uint8 pgIndex, char *pgName);
static int16 gmaTecFunEditResPG(sPlugInMenuItem_t *menuItem);

/**
 * This function will treat the message send by any plugin to add 
 * a menu item. See: \ref gmaPGSendMenuItem.
 *
 * @param appId the appId of the plugin that send the message
 *
 * @param msg the message send by the plugin that was the structure
 * \ref gmaStructPGMenuItem_t.
 */
int16 gmaTecFunMenuAddItem (uint16 appId, gmaStructHeader_t *msg)
{
	gmaStructPGMenuItem_t* msgIn;
	uint8 index;
	bool found = FALSE;

	msgIn = (gmaStructPGMenuItem_t*) msg;
	IFDEBUG(debugPrintf(DEBUG_PRN, "----------------"));
	
	IFDEBUG(debugPrintf(DEBUG_PRN, "add-appId=%d", appId));
	IFDEBUG(debugPrintf(DEBUG_PRN, "add-logId=%d", msgIn->pluginID));
	IFDEBUG(debugPrintf(DEBUG_PRN, "number=%d", numPlugInMenuItems));
	IFDEBUG(debugPrintf(DEBUG_PRN, "number=%d", msgIn->itemID));
	IFDEBUG(debugPrintf(DEBUG_PRN, "n=%s", msgIn->caption));
	
	gmaCustomSemaphoreAcquire(GMA_CUSTOM_SEMAPHORE_MENU_TABLE);
   
	memcpy(plugInMenu[numPlugInMenuItems].itemString, msgIn->caption,GMA_DISPLAY_NUM_COL);
	plugInMenu[numPlugInMenuItems].itemString[GMA_DISPLAY_NUM_COL] = 0;
	plugInMenu[numPlugInMenuItems].appId = appId;
	plugInMenu[numPlugInMenuItems].logicalId = msgIn->pluginID;
	plugInMenu[numPlugInMenuItems].itemId = msgIn->itemID;
	plugInMenu[numPlugInMenuItems].action = msgIn->action;
   plugInMenu[numPlugInMenuItems].parameter = msgIn->parameter;

	numPlugInMenuItems++;

	for (index=0;index<numPlugInItemsList;index++)
		if ((plugInList[index].appId==appId)&&(plugInList[index].logicalId==msgIn->pluginID))
		{
			plugInList[index].numOfItems++;
			found = TRUE;
			break;
		}

	if (!found)
	{
//		gmaAppListLogicalData_t* entry;

//      gmaAppListGetLogicalEntryFromId(msgIn->pluginID, appId, &entry);
		//IFDEBUG(debugPrintf(DEBUG_PRN, "pgName=%s", entry->tmName));
		plugInList[numPlugInItemsList].appId=appId;
		plugInList[numPlugInItemsList].logicalId=msgIn->pluginID;
//		memcpy(plugInList[numPlugInItemsList].PGName, entry->tmName,GMA_DISPLAY_NUM_COL);
//		plugInList[numPlugInItemsList].PGName[GMA_DISPLAY_NUM_COL] = 0;
		numPlugInItemsList++;
	}

	gmaCustomSemaphoreRelease(GMA_CUSTOM_SEMAPHORE_MENU_TABLE);

	return RET_OK;
}

/**
 * Display the technical function menu (menu generated by the plugins).
 */
int16 gmaTecFunDisplayPGMenu (void)
{
	uint16 index;
	uint8  choice;
	int16  retVal = GMA_APP_MENU_ERROR;
   int16 ret;
	char* itemList[GMA_MAX_PG_MENU_ITEMS];
   gmaAppListLogicalData_t* entry;
   
   
	for (index=0;index<numPlugInItemsList;index++)
	{
		//IFDEBUG(debugPrintf(DEBUG_PRN, "log=%d-appId=%d", plugInList[index].logicalId, plugInList[index].appId));
		
      ret = gmaAppListGetLogicalEntryFromId(plugInList[index].logicalId, plugInList[index].appId, &entry);
      //IFDEBUG(debugPrintf(DEBUG_PRN, "ret = %d", ret));
      if(ret== RET_OK)
      {
         itemList[index] = entry->tmName;
         //IFDEBUG(debugPrintf(DEBUG_PRN, "index=%d", index));
         
         //IFDEBUG(debugPrintf(DEBUG_PRN, "i=%s", entry->tmName));
      }
	}
	choice = 0;
	
	// 
	
	IFDEBUG(debugPrintf(DEBUG_PRN, "num=%d", numPlugInItemsList));
	
	
	while(1)
	{
	   retVal = gmaHmiMenu (gmaGetStringResource(GMA_PG_MENU_TITLE), (const char **)itemList, numPlugInItemsList, &choice, GMA_PG_MENU_TIMEOUT);
	
	   if (retVal==RET_OK)
	   {
	      retVal = gmaTecFunDisplayPGItemsMenu (choice, itemList[choice]);
	      if(retVal != RET_OK)
	      	return RET_OK;
	   }
	   else
	   {
	   	return retVal;
	   }
	}



}

/**
 * Display a menu of the specific plugin previous selected in the function
 * \ref gmaTecFunDisplayPGMenu.
 *
 * @param pgIndex index of the select plugin in the table \ref plugInList.
 * @param pgName Plugin name
 */
static int16 gmaTecFunDisplayPGItemsMenu (uint8 pgIndex, char *pgName)
{
	uint16 index;
	uint16 appId;
	uint16 count=0;
	uint8  choice;
	uint8 choice2;
	uint8 bContinue;
	uint8  logicalId;
	int16  retVal = GMA_APP_MENU_ERROR;
	uint8  indexList[GMA_MAX_PG_MENU_ITEMS];
	char*  itemList[GMA_MAX_PG_MENU_ITEMS];
	char title[16];
	
	for(choice = 0; pgName[choice]!=0 && choice<15; choice++)
	{
		title[choice] = toupper(pgName[choice]);
	}
	title[choice]=0;
	
	appId = plugInList[pgIndex].appId;
	logicalId = plugInList[pgIndex].logicalId;
	IFDEBUG(debugPrintf(DEBUG_PRN, "apId=%d - logId=%d", appId, logicalId));
	for (index=0;index<numPlugInMenuItems;index++)
	{
		IFDEBUG(debugPrintf(DEBUG_PRN, "aId=%d - lId=%d", plugInMenu[index].appId, plugInMenu[index].logicalId));
		if ((plugInMenu[index].appId==appId)&&(plugInMenu[index].logicalId==logicalId))
		{
			itemList[count] = plugInMenu[index].itemString;
			indexList[count] = (uint8) index;
			count++;
			IFDEBUG(debugPrintf(DEBUG_PRN, "found=%d", count));
		}
	}
	
	bContinue = 1;
	choice = 0;
	while(bContinue)
	{
		if(count == 1 && strlen(itemList[0]) == 0)
		{
			retVal = RET_OK;
			choice = 0;
			bContinue = 0;
		}
		else
		{
	   	retVal = gmaHmiMenu (title, (const char **)itemList, (uint8) count, &choice, GMA_PG_MENU_TIMEOUT);
		}
		if(retVal < 0)
			return RET_OK;
			
	   choice2 = indexList[choice];
	
      if(plugInMenu[choice2].action == GMA_PG_MENU_ACTION_NOTIFY)
      {
         retVal = gmaTecFunNotifyPG (plugInMenu[choice2].appId, plugInMenu[choice2].logicalId,
                  plugInMenu[choice2].itemId);
         if(retVal == -1)
         	return -1;
      }
      else if(plugInMenu[choice2].action == GMA_PG_MENU_ACTION_EDIT )
         retVal = gmaTecFunEditResPG(&plugInMenu[choice2]);
	}

	return retVal;
}

/**
 * When the action of the select plugin menu item is edit this
 * function is called to make the edition. An edition 
 * resource need to be set by the plugin. see \ref gmaPGSendEditResource.
 *
 * @param menuItem the menu item selected
 */
static int16 gmaTecFunEditResPG(sPlugInMenuItem_t *menuItem)
{
   uint8 item = (uint8) menuItem->parameter;
   uint8 i;
   int16 ret;
   char editItem[32];

   for(i=0; i<numPlugInEditRes; i++)
   {
      if(plugInEditResList[i].appId == menuItem->appId &&
         plugInEditResList[i].logicalId == menuItem->logicalId &&
         plugInEditResList[i].itemId == item)
      {

         // item found
         memset(editItem, 0, sizeof(editItem));
         ret = gmaHmiEditMask(plugInEditResList[i].mask, editItem, 
            plugInEditResList[i].minLength, plugInEditResList[i].caption);

         if(ret == RET_OK)
         {
            amgMsg_t msgSend, msgAnswer;

            gmaMsgSetLogicalId(menuItem->logicalId);

            gmaMsgEncode(&msgSend, GMA_MSG_PG_SET_CONFIG);

            gmaMsgAddPGSetConfig(menuItem->logicalId, item, (uint16)(strlen(editItem)+1), 
               (uint8 *)editItem);

            gmaMsgEndEncode();

            gmaAppMsgWakeApp(menuItem->appId, menuItem->logicalId, &msgSend, &msgAnswer);
    		gmaInitProcessResponse(menuItem->appId, &msgAnswer);
         }
      }     
   }
   return RET_OK;
}

/**
 * This function is called when the action of the selected plugin menu item
 * is send a notification to the plugin.
 *
 * @param appID appId of the plugin that add the selected menu item.
 *
 * @param logApp the pluginId of the plugin that add the selected menu item.
 *
 * @param itemId the id of the selected menu item.
 */
static int16 gmaTecFunNotifyPG(uint16 appID, uint8 logApp, uint8 itemId)
{
	amgMsg_t defaultMsg;
	amgMsg_t responseMsg;
	gmaStructHeader_t *header;
	uint16 length;
	uint8 found=0;
	
	gmaMsgEncode(&defaultMsg, GMA_MSG_PG_NOTIFY);
   gmaMsgSetLogicalId(logApp);
	gmaMsgAddNotificationType(logApp, GMA_NOTIFICATION_MENU, itemId);
	gmaMsgEndEncode();
	gmaAppMsgWakeApp(appID, logApp, &defaultMsg, &responseMsg);
	
	gmaMsgDecode(&responseMsg);
	while(gmaMsgRead((void **)&header, &length) == RET_OK)
	{
		if(header->id == GMA_STRUCT_PG_BACK_GMA)
			found = 1;
		else if (header->id == GMA_STRUCT_LOGICAL_APP_INFO)
			gmaInitProcessLogicalAppInfo(appID, &header);
	}
	gmaMsgEndDecode();
	if(found)
		return -1;
	return RET_OK;
}

/**
 * Treat the message receive from any plugin to add a edit string resource.
 *
 * @param i index in the table where the item will be added
 *
 * @param appId the appId of the plugin that sent the message
 *
 * @param msg the message sent by the plugin
 */
static void gmaTecFunSFillEditResStr(uint8 i, uint16 appId, gmaStructPGEditResource_t *msg)
{
   plugInEditResList[i].appId     = appId;
   plugInEditResList[i].logicalId = msg->pluginId;
   plugInEditResList[i].itemId    = msg->itemId;
   strcpy(plugInEditResList[i].caption, msg->caption);
   strcpy(plugInEditResList[i].mask, msg->mask);
   plugInEditResList[i].minLength = msg->minLength;
}

/**
 * Treat the message receive from any plugin to add a edit string resource.
 *
 * @param appId the appId of the plugin that sends the message
 *
 * @param msg the message sent by the plugin
 */
int16 gmaTecFunAddEditResource(uint16 appId, gmaStructPGEditResource_t *msg)
{
   uint8 i;
   for(i=0; i<numPlugInEditRes; i++)
   {
      if(plugInEditResList[i].appId == appId &&
         plugInEditResList[i].logicalId == msg->pluginId &&
         plugInEditResList[i].itemId == msg->itemId)
      {
         gmaTecFunSFillEditResStr(i, appId, msg);
      }
   }
   
   if(numPlugInEditRes >= GMA_MAX_PG_EDIT_RES_ITENS)
   {
      return -1;
   }
   gmaTecFunSFillEditResStr(numPlugInEditRes, appId, msg);
   numPlugInEditRes++;
   return RET_OK;
}
